// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel main
#pragma target 5

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
globallycoherent RWTexture3D<half4>	ColorData : register(u1);
globallycoherent RWTexture3D<half4> SurfaceData : register(u2);

float3 baseOffset;
float4 color0;
float4 color1;
float4 sliders;

int texWidth;
float blockWidth;

float4x4 start;
float4x4 end;




[numthreads(8, 8, 8)]
void main(uint3 id : SV_DispatchThreadID)
{
	float4 worldPos = float4((id + 0.5) * blockWidth / ((float)texWidth) + baseOffset, 1.0);
	float3 relStart = mul(start, worldPos).xyz;
	float3 relEnd = mul(end, worldPos).xyz;
	float3 sclStart = mul(start, float4(1,1,1,1)).xyz;
	float3 sclEnd = mul(end, float4(1, 1, 1, 1)).xyz;
	float3 brushDir = normalize(relEnd - relStart);
	float before = dot(relStart, brushDir);
	float after = dot(relEnd, brushDir);
	float3 pos;
	float3x3 normMat;
	float4 norm;
	float3 scaling;

	if (before >= 0) {
		pos = relStart;
		scaling = sclStart;
		normMat = transpose(start);
	}
	else if (after <= 0) {
		pos = relEnd;
		scaling = sclEnd;
		normMat = transpose(end);
	}
	else if (before == after) {
		pos = relStart;
		scaling = sclEnd;
		normMat = transpose(start);
	}
	else {
		pos = lerp(relStart, relEnd, 1.0 - (after) / (after - before));
		scaling = lerp(sclStart, sclEnd, 1.0 - (after) / (after - before));
		normMat = transpose(lerp(start, end, 1.0 - (after) / (after - before)));
	}
	if (length(pos) <= 1.0) {
		ColorData[id] = lerp(color0, color1, 1.0 - (after) / (after - before));
		if (length(pos)<0.9) {
			SurfaceData[id] = float4(0.0,0.0,0.0,0.0);
		}
		else {
			SurfaceData[id] = float4(normalize(mul(normMat, normalize(pos))), 0.0);
		}
	}
	

}
