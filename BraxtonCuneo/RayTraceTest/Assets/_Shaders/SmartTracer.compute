#pragma kernel main

static const uint3 gl_WorkGroupSize = uint3(8u, 8u, 1u);

static const uint _273[18] = { 64132284u, 50872888u, 26350396u, 26358936u, 43315464u, 64020664u, 26272920u, 63316496u, 64119996u, 26374296u, 26408100u, 59958460u, 30442524u, 59937976u, 64021564u, 64021536u, 38954148u, 0u };
static const uint _2850[32] = { 20u, 8u, 9u, 19u, 27u, 9u, 19u, 27u, 1u, 27u, 20u, 8u, 9u, 18u, 20u, 25u, 27u, 20u, 23u, 15u, 27u, 3u, 8u, 1u, 18u, 27u, 17u, 21u, 15u, 20u, 5u, 0u };
static const uint _2852[10] = { 2u, 1u, 4u, 27u, 1u, 12u, 12u, 15u, 3u, 0u };
static const uint _2854[9] = { 2u, 1u, 4u, 27u, 6u, 18u, 5u, 5u, 0u };

RWStructuredBuffer<uint> mem_man  : register(u2); 
RWStructuredBuffer<uint> trace  : register(u3); 
RWByteAddressBuffer no_unroll : register(u7);
RWStructuredBuffer<uint> geom  : register(u6); 
RWStructuredBuffer<uint> debug_log  : register(u0); 
RWStructuredBuffer<uint> data  : register(u1); 
cbuffer SPIRV_Cross_NumWorkgroups : register(b0)
{
    uint3 SPIRV_Cross_NumWorkgroups_1_count : packoffset(c0);
};

RWTexture2D<float4> color_texture : register(u4);
Texture2D<float4> old_depth : register(t5);
SamplerState _old_depth_sampler : register(s5);

static uint3 gl_GlobalInvocationID;
static uint gl_LocalInvocationIndex;
struct SPIRV_Cross_Input
{
    uint3 gl_GlobalInvocationID : SV_DispatchThreadID;
    uint gl_LocalInvocationIndex : SV_GroupIndex;
};

static bool _log_overflow;
static uint _current_chunk;
static uint _log_pos;
static uint uint_to_exact_table;
static uint all_locked_treelet;
static uint all_free_treelet;
static bool actually_alloced;
static uint bucket;
static uint last;
static uint last_succ_adr;
static uint fail_count;
static uint na_hash;
static uint num_sprites[18];
groupshared uint no_unroll_shared;
static uint last_modify;
static uint fail_level;
static uint last_fail_count;
static uint gid;
static uint _charbuff[5];
static uint hmm;

uint _388;
uint _779;
uint _859;
uint _939;
uint _997;
uint _1086;
uint _1144;

void galloc_initialize()
{
    uint3 sWG = uint3(1u, 1u, 1u);
    uint3 nWG = SPIRV_Cross_NumWorkgroups_1_count;
    uint3 gID = gl_GlobalInvocationID;
    uint item_id = (gID.x + ((gID.y * sWG.x) * nWG.x)) + ((((gID.z * sWG.x) * nWG.x) * sWG.y) * nWG.y);
    gid = item_id;
    last = gid;
}

bool uniforms_bad()
{
    bool _2335 = any(bool2(uint2(trace[(0)/4],trace[(0)/4+1]).x < uint2(0u, 0u).x, uint2(trace[(0)/4],trace[(0)/4+1]).y < uint2(0u, 0u).y));
    bool _2345;
    if (!_2335)
    {
        _2345 = any(bool2(uint2(trace[(0)/4],trace[(0)/4+1]).x > uint2(10000u, 10000u).x, uint2(trace[(0)/4],trace[(0)/4+1]).y > uint2(10000u, 10000u).y));
    }
    else
    {
        _2345 = _2335;
    }
    bool _2357;
    if (!_2345)
    {
        _2357 = any(bool4(asfloat(uint4(trace[(16)/4],trace[(16)/4+1],trace[(16)/4+2],trace[(16)/4+3])).x <= 0.0f.xxxx.x, asfloat(uint4(trace[(16)/4],trace[(16)/4+1],trace[(16)/4+2],trace[(16)/4+3])).y <= 0.0f.xxxx.y, asfloat(uint4(trace[(16)/4],trace[(16)/4+1],trace[(16)/4+2],trace[(16)/4+3])).z <= 0.0f.xxxx.z, asfloat(uint4(trace[(16)/4],trace[(16)/4+1],trace[(16)/4+2],trace[(16)/4+3])).w <= 0.0f.xxxx.w));
    }
    else
    {
        _2357 = _2345;
    }
    bool _2367;
    if (!_2357)
    {
        _2367 = length(asfloat(uint3(trace[(48)/4],trace[(48)/4+1],trace[(48)/4+2]))) >= 100000.9921875f;
    }
    else
    {
        _2367 = _2357;
    }
    return _2367;
}

uint FNV1_a_hash_combine(uint old_hash, uint val)
{
    uint h = old_hash;
    for (uint i = 0u; i < 4u; i++)
    {
        h ^= (val & 255u);
        h *= 16777619u;
        h = h >> uint(8);
    }
    return h;
}

uint next_alloc_idx(uint level)
{
    uint level_mag = 1u << level;
    uint adr_mask = 65535u & (~(level_mag - 1u));
    uint param = na_hash;
    uint param_1 = last + last_succ_adr;
    na_hash = FNV1_a_hash_combine(param, param_1) - 1u;
    uint hash_offset = (na_hash & 7u) + 1u;
    last = ((last + (((fail_count * fail_count) * level_mag) * hash_offset)) + uint(1 << int(fail_level))) & adr_mask;
    last_fail_count = fail_count;
    return last;
}

void break_index(inout uint index, inout uint level, inout uint tier, out uint subtier, out uint t_index, out uint l_index, out uint lowest_bit, inout bool is_lowest)
{
    is_lowest = level == 0u;
    lowest_bit = 0u;
    if (is_lowest)
    {
        lowest_bit = index & 1u;
    }
    else
    {
        level--;
    }
    index = index >> 1u;
    tier = level / 4u;
    uint tier_levs = tier * 4u;
    subtier = level - tier_levs;
    uint s_index = index >> tier_levs;
    uint level_index_mask = 7u;
    l_index = s_index & level_index_mask;
    t_index = s_index >> 3u;
}

uint tier_offset(inout uint tier)
{
    tier = 3u - tier;
    if (tier == 0u)
    {
        return 0u;
    }
    return ((1u << (tier * 4u)) - 1u) / 15u;
}

uint from_triple(uint t)
{
    return 15u & (2258383380u >> (t * 4u));
}

void decode_double_partial(uint leaflet, out uint left, out uint right)
{
    uint param = 7u & leaflet;
    right = from_triple(param);
    uint param_1 = 7u & (leaflet >> uint(3));
    left = from_triple(param_1);
}

void decode_range(uint leaflet, out uint result)
{
    uint code = leaflet;
    if ((code & 12u) == 12u)
    {
        result = 17u + (code & 3u);
    }
    else
    {
        result = 21u + ((code >> uint(2)) & 3u);
    }
}

void decode_double_exact(uint leaflet, out uint left, out uint right)
{
    uint code = leaflet - 64u;
    left = (code << uint(2)) & 48u;
    right = (code << uint(4)) & 48u;
}

void decode_single_exact(uint leaflet, out uint left, out uint right)
{
    uint code = (leaflet - 80u) >> uint(3);
    uint exact_code = ((uint_to_exact_table >> (code * 2u)) & 3u) << uint(4);
    if (code < 3u)
    {
        left = exact_code;
        uint param = leaflet & 7u;
        right = from_triple(param);
    }
    else
    {
        right = exact_code;
        uint param_1 = leaflet & 7u;
        left = from_triple(param_1);
    }
}

void read_leaflet(uint treelet, uint index, inout uint left, out uint right)
{
    uint leaflet = 127u & (treelet >> (7u * index));
    if (leaflet < 64u)
    {
        uint param = leaflet;
        uint param_1;
        uint param_2;
        decode_double_partial(param, param_1, param_2);
        left = param_1;
        right = param_2;
    }
    else
    {
        if (leaflet < 80u)
        {
            bool _542 = (leaflet & 3u) == 3u;
            bool _549;
            if (!_542)
            {
                _549 = (leaflet & 12u) == 12u;
            }
            else
            {
                _549 = _542;
            }
            if (_549)
            {
                uint param_3 = leaflet;
                uint param_4;
                decode_range(param_3, param_4);
                left = param_4;
                right = left;
            }
            else
            {
                uint param_5 = leaflet;
                uint param_6;
                uint param_7;
                decode_double_exact(param_5, param_6, param_7);
                left = param_6;
                right = param_7;
            }
        }
        else
        {
            uint param_8 = leaflet;
            uint param_9;
            uint param_10;
            decode_single_exact(param_8, param_9, param_10);
            left = param_9;
            right = param_10;
        }
    }
}

bool all_locked_or_free(uint treelet)
{
    uint mask = 19u;
    uint left;
    uint right;
    for (uint i = 0u; i < (4u * (no_unroll_shared + 1u)); i++)
    {
        uint param = treelet;
        uint param_1 = i;
        uint param_2 = left;
        uint param_3 = right;
        read_leaflet(param, param_1, param_2, param_3);
        left = param_2;
        right = param_3;
        bool _669 = (left & mask) != 0u;
        bool _677;
        if (!_669)
        {
            _677 = (right & mask) != 0u;
        }
        else
        {
            _677 = _669;
        }
        if (_677)
        {
            return false;
        }
    }
    return true;
}

uint encode_range(uint leaflet)
{
    uint code = leaflet - 17u;
    if (code < 4u)
    {
        return (64u + code) | 12u;
    }
    else
    {
        return (64u + ((code - 4u) << uint(2))) | 3u;
    }
}

uint encode_double_exact(uint left, uint right)
{
    uint code = (left >> uint(2)) | (right >> uint(4));
    return code + 64u;
}

uint to_triple(inout uint t)
{
    uint chunk = 4142936607u;
    if (t >= 8u)
    {
        chunk = 4294246231u;
        t -= 8u;
    }
    return 15u & (chunk >> (t * 4u));
}

uint encode_single_exact(uint left, uint right)
{
    uint code;
    uint part;
    if ((left & 15u) == 0u)
    {
        code = left >> uint(4);
        uint param = right;
        uint _502 = to_triple(param);
        part = _502;
    }
    else
    {
        code = 3u + (right >> uint(4));
        uint param_1 = left;
        uint _509 = to_triple(param_1);
        part = _509;
    }
    return ((code << uint(3)) + 80u) | part;
}

uint encode_double_partial(uint left, uint right)
{
    uint param = left;
    uint _341 = to_triple(param);
    uint param_1 = right;
    uint _345 = to_triple(param_1);
    return (_341 << uint(3)) | _345;
}

uint write_leaflet(inout uint treelet, uint index, uint left, uint right)
{
    uint lower_count = uint((left & 15u) != 0u) + uint((right & 15u) != 0u);
    uint leaflet;
    if ((left >= 17u) && (left != 32u))
    {
        uint param = left;
        leaflet = encode_range(param);
    }
    else
    {
        if (lower_count == 0u)
        {
            uint param_1 = left;
            uint param_2 = right;
            leaflet = encode_double_exact(param_1, param_2);
        }
        else
        {
            if (lower_count == 1u)
            {
                uint param_3 = left;
                uint param_4 = right;
                leaflet = encode_single_exact(param_3, param_4);
            }
            else
            {
                uint param_5 = left;
                uint param_6 = right;
                leaflet = encode_double_partial(param_5, param_6);
            }
        }
    }
    treelet &= uint(~(127 << int(7u * index)));
    treelet |= (leaflet << (7u * index));
    return treelet;
}

uint part_alloc(uint treelet, uint index, inout uint succ)
{
    uint leaflet_idx = index >> 2u;
    uint pos = (index & 2u) >> uint(1);
    uint pos2 = index & 1u;
    uint w_mask = uint(1 << int(pos2));
    uint t_mask = 48u | w_mask;
    uint param = treelet;
    uint param_1 = leaflet_idx;
    uint left;
    uint param_2 = left;
    uint right;
    uint param_3 = right;
    read_leaflet(param, param_1, param_2, param_3);
    left = param_2;
    right = param_3;
    uint val = left;
    if (pos == 0u)
    {
        val = right;
    }
    if ((val & t_mask) == 0u)
    {
        if ((val & (w_mask << 2u)) == 0u)
        {
            actually_alloced = true;
        }
        else
        {
            actually_alloced = false;
        }
        val &= (~(w_mask << 2u));
        val |= w_mask;
        if (pos == 0u)
        {
            right = val;
        }
        else
        {
            left = val;
        }
        uint param_4 = treelet;
        succ = uint(!all_locked_or_free(param_4));
        uint param_5 = treelet;
        uint param_6 = leaflet_idx;
        uint param_7 = left;
        uint param_8 = right;
        uint _769 = write_leaflet(param_5, param_6, param_7, param_8);
        return _769;
    }
    else
    {
        actually_alloced = false;
        succ = uint((val & 48u) != 0u) + 1u;
        return treelet;
    }
}

uint retry_modify(uint idx, uint new_value, inout uint old_value)
{
    if (new_value == old_value)
    {
        return 0u;
    }
    uint _1375;
    InterlockedCompareExchange(mem_man[(idx * 4 + 4)/4], old_value, new_value, _1375);
    uint swap = _1375;
    uint result = uint((swap == old_value) ? 0 : 2);
    if (swap == old_value)
    {
        old_value = new_value;
        last_modify = new_value;
    }
    else
    {
        old_value = swap;
        last_modify = swap;
    }
    return result;
}

uint try_part_alloc(uint tier, uint tier_index, uint local_index)
{
    uint param = tier;
    uint _1399 = tier_offset(param);
    uint true_index = tier_index + _1399;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint succ = 0u;
    uint ch_succ = 2u;
    uint param_3;
    while ((succ != 2u) && (ch_succ == 2u))
    {
        uint true_old = old_treelet;
        uint param_1 = old_treelet;
        uint param_2 = local_index;
        uint _1425 = part_alloc(param_1, param_2, param_3);
        succ = param_3;
        uint new_treelet = _1425;
        if (succ != 2u)
        {
            uint param_4 = true_index;
            uint param_5 = new_treelet;
            uint param_6 = old_treelet;
            uint _1438 = retry_modify(param_4, param_5, param_6);
            old_treelet = param_6;
            ch_succ = max(succ, _1438);
        }
    }
    return ch_succ;
}

uint leaf_alloc(uint treelet, uint index, inout uint succ)
{
    uint leaflet_idx = index >> 1u;
    uint pos = index & 1u;
    uint param = treelet;
    uint param_1 = leaflet_idx;
    uint left;
    uint param_2 = left;
    uint right;
    uint param_3 = right;
    read_leaflet(param, param_1, param_2, param_3);
    left = param_2;
    right = param_3;
    uint val = left;
    if (pos == 0u)
    {
        val = right;
    }
    if ((val & 63u) == 0u)
    {
        if (pos == 0u)
        {
            right = 16u;
        }
        else
        {
            left = 16u;
        }
        uint param_4 = treelet;
        uint param_5 = leaflet_idx;
        uint param_6 = left;
        uint param_7 = right;
        uint _986 = write_leaflet(param_4, param_5, param_6, param_7);
        uint new_treelet = _986;
        uint param_8 = treelet;
        succ = uint(!all_locked_or_free(param_8));
        return new_treelet;
    }
    else
    {
        succ = 2u;
        return treelet;
    }
}

bool all_free(uint treelet)
{
    return treelet == 135274560u;
}

uint write_range(uint treelet, uint level, uint index, uint val)
{
    uint scale = uint(1 << int(level));
    uint start = index;
    uint lim = start + scale;
    uint head = treelet >> (lim * 7u);
    uint tail = treelet & uint((1 << int(start * 7u)) - 1);
    uint result = head;
    for (uint i = index; i < lim; i++)
    {
        result = result << uint(7);
        result |= val;
    }
    result = result << (start * 7u);
    result |= tail;
    return result;
}

uint range_alloc(uint treelet, inout uint level, uint index, inout uint succ)
{
    uint param = 17u + level;
    uint val = encode_range(param);
    level--;
    uint lim = uint(1 << int(level));
    uint left;
    uint right;
    for (uint i = 0u; i < (lim * (no_unroll_shared + 1u)); i++)
    {
        uint param_1 = treelet;
        uint param_2 = index + i;
        uint param_3 = left;
        uint param_4 = right;
        read_leaflet(param_1, param_2, param_3, param_4);
        left = param_3;
        right = param_4;
        if ((left != 0u) || (right != 0u))
        {
            succ = 2u;
            return treelet;
        }
    }
    uint param_5 = treelet;
    succ = uint(!all_free(param_5));
    uint param_6 = treelet;
    uint param_7 = level;
    uint param_8 = index;
    uint param_9 = val;
    return write_range(param_6, param_7, param_8, param_9);
}

uint try_modify(uint idx, uint new_value, uint old_value)
{
    if (new_value == old_value)
    {
        return 0u;
    }
    uint _1346;
    InterlockedCompareExchange(mem_man[(idx * 4 + 4)/4], old_value, new_value, _1346);
    uint swap = _1346;
    if (swap == old_value)
    {
        last_modify = new_value;
    }
    else
    {
        last_modify = swap;
    }
    return uint((swap == old_value) ? 0 : 2);
}

uint try_base_alloc(uint true_index, uint subtier, uint level_index)
{
    uint succ = 2u;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint new_treelet;
    if (subtier == 0u)
    {
        uint param = old_treelet;
        uint param_1 = level_index;
        uint param_2;
        uint _1659 = leaf_alloc(param, param_1, param_2);
        succ = param_2;
        new_treelet = _1659;
    }
    else
    {
        uint param_3 = old_treelet;
        uint param_4 = subtier;
        uint param_5 = level_index >> uint(1);
        uint param_6;
        uint _1670 = range_alloc(param_3, param_4, param_5, param_6);
        succ = param_6;
        new_treelet = _1670;
    }
    if (succ == 2u)
    {
        return succ;
    }
    uint param_7 = true_index;
    uint param_8 = new_treelet;
    uint param_9 = old_treelet;
    uint _1685 = try_modify(param_7, param_8, param_9);
    return max(succ, _1685);
}

void print_treelet(uint treelet)
{
}

void level_up_index(inout uint tier_index, out uint level_index)
{
    level_index = tier_index & 15u;
    tier_index = tier_index >> 4u;
}

uint part_lock(inout uint treelet, uint index, inout uint succ)
{
    uint leaflet_idx = index >> 2u;
    uint pos = (index & 2u) >> uint(1);
    uint pos2 = index & 1u;
    uint t_mask = uint(1 << int(pos2));
    uint w_mask = t_mask << uint(2);
    uint param = treelet;
    uint param_1 = leaflet_idx;
    uint left;
    uint param_2 = left;
    uint right;
    uint param_3 = right;
    read_leaflet(param, param_1, param_2, param_3);
    left = param_2;
    right = param_3;
    uint val = left;
    if (pos == 0u)
    {
        val = right;
    }
    if (((val & t_mask) != 0u) && (val < 16u))
    {
        val &= (~t_mask);
        val |= w_mask;
        if (pos == 0u)
        {
            right = val;
        }
        else
        {
            left = val;
        }
        uint param_4 = treelet;
        uint param_5 = leaflet_idx;
        uint param_6 = left;
        uint param_7 = right;
        uint _928 = write_leaflet(param_4, param_5, param_6, param_7);
        treelet = _928;
        uint param_8 = treelet;
        succ = uint(!all_locked_or_free(param_8));
        return treelet;
    }
    else
    {
        succ = 2u;
        return treelet;
    }
}

uint try_part_lock(uint tier, uint tier_index, uint local_index)
{
    uint param = tier;
    uint _1448 = tier_offset(param);
    uint true_index = tier_index + _1448;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint succ = 0u;
    uint ch_succ = 2u;
    uint param_3;
    while ((succ != 2u) && (ch_succ == 2u))
    {
        uint param_1 = old_treelet;
        uint param_2 = local_index;
        uint _1472 = part_lock(param_1, param_2, param_3);
        succ = param_3;
        uint new_treelet = _1472;
        if (succ != 2u)
        {
            uint param_4 = true_index;
            uint param_5 = new_treelet;
            uint param_6 = old_treelet;
            uint _1485 = retry_modify(param_4, param_5, param_6);
            old_treelet = param_6;
            ch_succ = max(succ, _1485);
        }
    }
    if (ch_succ != 2u)
    {
    }
    return ch_succ;
}

uint part_free(inout uint treelet, uint index, inout uint succ)
{
    uint leaflet_idx = index >> 2u;
    uint pos = (index & 2u) >> 1u;
    uint pos2 = index & 1u;
    uint mask = uint(4 << int(pos2));
    uint param = treelet;
    uint param_1 = leaflet_idx;
    uint left;
    uint param_2 = left;
    uint right;
    uint param_3 = right;
    read_leaflet(param, param_1, param_2, param_3);
    left = param_2;
    right = param_3;
    uint val = left;
    if (pos == 0u)
    {
        val = right;
    }
    if (((val & mask) != 0u) && (val < 16u))
    {
        val &= (~mask);
        if (pos == 0u)
        {
            right = val;
        }
        else
        {
            left = val;
        }
        uint param_4 = treelet;
        uint param_5 = leaflet_idx;
        uint param_6 = left;
        uint param_7 = right;
        uint _843 = write_leaflet(param_4, param_5, param_6, param_7);
        treelet = _843;
        uint param_8 = treelet;
        succ = uint(!all_free(param_8));
        if (succ == 0u)
        {
            treelet = all_locked_treelet;
        }
        return treelet;
    }
    else
    {
        succ = 2u;
        return treelet;
    }
}

uint try_part_free(uint tier, uint tier_index, uint local_index)
{
    uint param = tier;
    uint _1599 = tier_offset(param);
    uint true_index = tier_index + _1599;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint succ = 0u;
    uint ch_succ = 2u;
    uint param_3;
    while ((succ != 2u) && (ch_succ == 2u))
    {
        uint true_old = old_treelet;
        uint param_1 = old_treelet;
        uint param_2 = local_index;
        uint _1625 = part_free(param_1, param_2, param_3);
        succ = param_3;
        uint new_treelet = _1625;
        if (succ != 2u)
        {
            uint param_4 = true_index;
            uint param_5 = new_treelet;
            uint param_6 = old_treelet;
            uint _1638 = retry_modify(param_4, param_5, param_6);
            old_treelet = param_6;
            ch_succ = max(succ, _1638);
        }
    }
    return ch_succ;
}

uint leaf_free(uint treelet, uint index, inout uint succ)
{
    uint leaflet_idx = index >> 1u;
    uint pos = index & 1u;
    uint param = treelet;
    uint param_1 = leaflet_idx;
    uint left;
    uint param_2 = left;
    uint right;
    uint param_3 = right;
    read_leaflet(param, param_1, param_2, param_3);
    left = param_2;
    right = param_3;
    uint val = left;
    if (pos == 0u)
    {
        val = right;
    }
    if (val == 16u)
    {
        if (pos == 0u)
        {
            right = 0u;
        }
        else
        {
            left = 0u;
        }
        uint param_4 = treelet;
        uint param_5 = leaflet_idx;
        uint param_6 = left;
        uint param_7 = right;
        uint _1131 = write_leaflet(param_4, param_5, param_6, param_7);
        uint new_treelet = _1131;
        uint param_8 = new_treelet;
        if (all_free(param_8))
        {
            succ = 0u;
            new_treelet = all_locked_treelet;
        }
        else
        {
            succ = 1u;
        }
        return new_treelet;
    }
    else
    {
        succ = 2u;
        return treelet;
    }
}

uint range_free(uint treelet, inout uint level, uint index, inout uint succ)
{
    uint param = 0u;
    uint param_1 = 0u;
    uint val = encode_double_exact(param, param_1);
    uint test = 17u + level;
    level--;
    uint lim = 1u << level;
    uint left;
    uint right;
    for (uint i = 0u; i < (lim * (no_unroll_shared + 1u)); i++)
    {
        uint param_2 = treelet;
        uint param_3 = index + i;
        uint param_4 = left;
        uint param_5 = right;
        read_leaflet(param_2, param_3, param_4, param_5);
        left = param_4;
        right = param_5;
        if ((left != test) || (right != test))
        {
            succ = 2u;
            return treelet;
        }
    }
    uint param_6 = treelet;
    uint param_7 = level;
    uint param_8 = index;
    uint param_9 = val;
    uint new_treelet = write_range(param_6, param_7, param_8, param_9);
    uint param_10 = new_treelet;
    if (all_free(param_10))
    {
        succ = 0u;
        new_treelet = all_locked_treelet;
    }
    else
    {
        succ = 1u;
    }
    return new_treelet;
}

uint try_base_free(uint true_index, uint subtier, uint level_index)
{
    uint succ = 0u;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint ch_succ = 2u;
    uint new_treelet;
    if (subtier == 0u)
    {
        uint param_2;
        while ((succ != 2u) && (ch_succ == 2u))
        {
            uint param = old_treelet;
            uint param_1 = level_index;
            uint _1715 = leaf_free(param, param_1, param_2);
            succ = param_2;
            new_treelet = _1715;
            if (succ != 2u)
            {
                uint param_3 = true_index;
                uint param_4 = new_treelet;
                uint param_5 = old_treelet;
                uint _1728 = retry_modify(param_3, param_4, param_5);
                old_treelet = param_5;
                ch_succ = max(succ, _1728);
            }
        }
    }
    else
    {
        uint param_9;
        while ((succ != 2u) && (ch_succ == 2u))
        {
            uint param_6 = old_treelet;
            uint param_7 = subtier;
            uint param_8 = level_index >> uint(1);
            uint _1750 = range_free(param_6, param_7, param_8, param_9);
            succ = param_9;
            new_treelet = _1750;
            if (succ != 2u)
            {
                uint param_10 = true_index;
                uint param_11 = new_treelet;
                uint param_12 = old_treelet;
                uint _1763 = retry_modify(param_10, param_11, param_12);
                old_treelet = param_12;
                ch_succ = max(succ, _1763);
            }
        }
    }
    if (succ != 2u)
    {
    }
    return ch_succ;
}

uint try_resolve(uint tier, uint tier_index)
{
    uint param = tier;
    uint _1548 = tier_offset(param);
    uint true_index = tier_index + _1548;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint succ = 0u;
    uint ch_succ = 2u;
    uint new_treelet;
    while ((succ != 2u) && (ch_succ == 2u))
    {
        if (old_treelet == all_locked_treelet)
        {
            succ = 0u;
            new_treelet = all_free_treelet;
        }
        else
        {
            uint param_1 = old_treelet;
            print_treelet(param_1);
            succ = 1u;
            new_treelet = old_treelet;
        }
        if (succ != 2u)
        {
            uint param_2 = true_index;
            uint param_3 = new_treelet;
            uint param_4 = old_treelet;
            uint _1589 = retry_modify(param_2, param_3, param_4);
            old_treelet = param_4;
            ch_succ = max(succ, _1589);
        }
    }
    return ch_succ;
}

uint upward_free(uint treelet, uint part_index, inout uint succ)
{
    uint part_pos = part_index & 1u;
    uint index = part_index >> 1u;
    uint leaflet_idx = index >> 1u;
    uint pos = index & 1u;
    uint mask = uint(4 << int(part_pos));
    uint param = treelet;
    uint param_1 = leaflet_idx;
    uint left;
    uint param_2 = left;
    uint right;
    uint param_3 = right;
    read_leaflet(param, param_1, param_2, param_3);
    left = param_2;
    right = param_3;
    uint val = left;
    if (pos == 0u)
    {
        val = right;
    }
    if (val == 0u)
    {
        succ = 1u;
        return treelet;
    }
    else
    {
        bool _1042 = val < 16u;
        bool _1049;
        if (_1042)
        {
            _1049 = (val & mask) != 0u;
        }
        else
        {
            _1049 = _1042;
        }
        if (_1049)
        {
            uint new_val = val & (~mask);
            if (pos == 0u)
            {
                right = new_val;
            }
            else
            {
                left = new_val;
            }
            uint param_4 = treelet;
            uint param_5 = leaflet_idx;
            uint param_6 = left;
            uint param_7 = right;
            uint _1073 = write_leaflet(param_4, param_5, param_6, param_7);
            uint new_treelet = _1073;
            uint param_8 = new_treelet;
            if (all_free(param_8))
            {
                new_treelet = all_locked_treelet;
                succ = 0u;
            }
            else
            {
                succ = 1u;
            }
            return new_treelet;
        }
        else
        {
            succ = 1u;
            return treelet;
        }
    }
}

uint try_upward_free(uint tier, uint tier_index, uint local_index)
{
    uint param = tier;
    uint _1499 = tier_offset(param);
    uint true_index = tier_index + _1499;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint succ = 0u;
    uint ch_succ = 2u;
    uint param_3;
    while ((succ != 2u) && (ch_succ == 2u))
    {
        uint true_old = old_treelet;
        uint param_1 = old_treelet;
        uint param_2 = local_index;
        uint _1525 = upward_free(param_1, param_2, param_3);
        succ = param_3;
        uint new_treelet = _1525;
        if (succ != 2u)
        {
            uint param_4 = true_index;
            uint param_5 = new_treelet;
            uint param_6 = old_treelet;
            uint _1538 = retry_modify(param_4, param_5, param_6);
            old_treelet = param_6;
            ch_succ = max(succ, _1538);
        }
    }
    return ch_succ;
}

bool try_free(inout uint level, inout uint index, uint top_tier)
{
    uint param = index;
    uint param_1 = level;
    uint param_2;
    uint param_3;
    uint param_4;
    uint param_5;
    uint param_6;
    bool param_7;
    break_index(param, param_1, param_2, param_3, param_4, param_5, param_6, param_7);
    index = param;
    level = param_1;
    uint tier = param_2;
    uint subtier = param_3;
    uint tier_index = param_4;
    uint level_index = param_5;
    uint lowest_bit = param_6;
    bool is_lowest = param_7;
    uint last_tier_index = tier_index;
    uint last_level_index = level_index;
    uint param_8 = tier_index;
    uint param_9 = level_index;
    level_up_index(param_8, param_9);
    tier_index = param_8;
    level_index = param_9;
    uint param_10 = tier;
    uint _1813 = tier_offset(param_10);
    uint true_index = last_tier_index + _1813;
    uint succ;
    if (is_lowest)
    {
        uint param_11 = 0u;
        uint param_12 = last_tier_index;
        uint param_13 = (last_level_index * 2u) + lowest_bit;
        uint _1827 = try_part_lock(param_11, param_12, param_13);
        succ = _1827;
        uint param_14 = last_modify;
        print_treelet(param_14);
        uint param_15 = 0u;
        uint param_16 = last_tier_index;
        uint param_17 = (last_level_index * 2u) + lowest_bit;
        uint _1839 = try_part_free(param_15, param_16, param_17);
        succ = _1839;
        uint param_18 = last_modify;
        print_treelet(param_18);
    }
    else
    {
        uint param_19 = true_index;
        uint param_20 = subtier;
        uint param_21 = last_level_index;
        uint _1850 = try_base_free(param_19, param_20, param_21);
        succ = _1850;
        uint param_22 = last_modify;
        print_treelet(param_22);
    }
    if (succ == 2u)
    {
        return false;
    }
    else
    {
        if (succ == 1u)
        {
            return true;
        }
    }
    uint parent_succ;
    if (tier < top_tier)
    {
        uint param_23 = tier + 1u;
        uint param_24 = tier_index;
        uint param_25 = level_index;
        uint _1878 = try_part_lock(param_23, param_24, param_25);
        parent_succ = _1878;
        uint param_26 = last_modify;
        print_treelet(param_26);
    }
    if (succ == 2u)
    {
        return false;
    }
    else
    {
        if (succ == 1u)
        {
            return true;
        }
    }
    uint param_27 = tier;
    uint param_28 = last_tier_index;
    uint _1897 = try_resolve(param_27, param_28);
    succ = _1897;
    uint param_29 = last_modify;
    print_treelet(param_29);
    if (succ == 2u)
    {
        return false;
    }
    else
    {
        if (succ == 1u)
        {
            return true;
        }
    }
    if (parent_succ == 2u)
    {
        return false;
    }
    uint climb_tier = tier + 1u;
    for (; climb_tier < (top_tier * (no_unroll_shared + 1u)); climb_tier++)
    {
        last_tier_index = tier_index;
        last_level_index = level_index;
        uint param_30 = tier_index;
        uint param_31 = level_index;
        level_up_index(param_30, param_31);
        tier_index = param_30;
        level_index = param_31;
        uint param_32 = climb_tier;
        uint param_33 = last_tier_index;
        uint param_34 = last_level_index;
        uint _1946 = try_upward_free(param_32, param_33, param_34);
        succ = _1946;
        if (succ == 1u)
        {
            return true;
        }
        else
        {
            uint param_35 = last_modify;
            print_treelet(param_35);
        }
        uint param_36 = climb_tier + 1u;
        uint param_37 = tier_index;
        uint param_38 = level_index;
        uint _1964 = try_part_lock(param_36, param_37, param_38);
        uint next_succ = _1964;
        uint param_39 = last_modify;
        print_treelet(param_39);
        if (next_succ == 2u)
        {
        }
        uint param_40 = climb_tier;
        uint param_41 = last_tier_index;
        uint _1976 = try_resolve(param_40, param_41);
        succ = _1976;
        uint param_42 = last_modify;
        print_treelet(param_42);
        if (succ == 2u)
        {
            return false;
        }
        if (next_succ == 2u)
        {
            break;
        }
    }
    if (succ == 0u)
    {
        uint param_43 = climb_tier;
        uint param_44 = tier_index;
        uint param_45 = level_index;
        uint _2002 = try_part_free(param_43, param_44, param_45);
        succ = _2002;
        uint param_46 = last_modify;
        print_treelet(param_46);
        if (succ == 0u)
        {
            uint param_47 = climb_tier;
            uint param_48 = tier_index;
            uint _2014 = try_resolve(param_47, param_48);
            uint param_49 = last_modify;
            print_treelet(param_49);
        }
    }
    else
    {
        return false;
    }
    return true;
}

bool try_alloc(inout uint level, inout uint index)
{
    fail_level = 0u;
    uint old_level = level;
    uint old_index = index;
    uint param = index;
    uint param_1 = level;
    uint param_2;
    uint param_3;
    uint param_4;
    uint param_5;
    uint param_6;
    bool param_7;
    break_index(param, param_1, param_2, param_3, param_4, param_5, param_6, param_7);
    index = param;
    level = param_1;
    uint tier = param_2;
    uint subtier = param_3;
    uint tier_index = param_4;
    uint level_index = param_5;
    uint lowest_bit = param_6;
    bool is_lowest = param_7;
    uint param_8 = tier;
    uint _2056 = tier_offset(param_8);
    uint true_index = tier_index + _2056;
    uint succ;
    if (is_lowest)
    {
        uint param_9 = 0u;
        uint param_10 = tier_index;
        uint param_11 = (level_index * 2u) + lowest_bit;
        uint _2070 = try_part_alloc(param_9, param_10, param_11);
        succ = _2070;
    }
    else
    {
        fail_level++;
        uint param_12 = true_index;
        uint param_13 = subtier;
        uint param_14 = level_index;
        uint _2080 = try_base_alloc(param_12, param_13, param_14);
        succ = _2080;
        if (succ != 2u)
        {
        }
    }
    if (succ != 2u)
    {
        uint param_15 = last_modify;
        print_treelet(param_15);
    }
    else
    {
        return false;
    }
    uint climb_tier = tier + 1u;
    for (; climb_tier < (4u * (no_unroll_shared + 1u)); climb_tier++)
    {
        if (succ == 2u)
        {
            break;
        }
        fail_level++;
        uint param_16 = tier_index;
        uint param_17 = level_index;
        level_up_index(param_16, param_17);
        tier_index = param_16;
        level_index = param_17;
        uint param_18 = climb_tier;
        uint param_19 = tier_index;
        uint param_20 = level_index;
        uint _2127 = try_part_alloc(param_18, param_19, param_20);
        succ = _2127;
        if (succ != 2u)
        {
            uint param_21 = last_modify;
            print_treelet(param_21);
        }
    }
    if (succ != 2u)
    {
        fail_level = 0u;
        return true;
    }
    uint param_22 = old_level;
    uint param_23 = old_index;
    uint param_24 = climb_tier;
    bool _2149 = try_free(param_22, param_23, param_24);
    bool good_free = _2149;
    if (!good_free)
    {
    }
    return false;
}

uint alloc(uint level)
{
    if (bucket != 3735928559u)
    {
        uint ret = bucket;
        bucket = 3735928559u;
        return ret;
    }
    uint param = level;
    uint _2208 = next_alloc_idx(param);
    uint index = _2208;
    uint tries = 0u;
    tries = 0u;
    for (; tries < (30u * (no_unroll_shared + 1u)); tries++)
    {
        if (tries != 0u)
        {
            fail_count++;
        }
        uint param_1 = level;
        uint param_2 = index;
        bool _2231 = try_alloc(param_1, param_2);
        if (_2231)
        {
            break;
        }
        uint param_3 = level;
        uint _2237 = next_alloc_idx(param_3);
        index = _2237;
    }
    if (tries >= 30u)
    {
        return 3735928559u;
    }
    fail_count = 1u;
    last_succ_adr = index;
    uint adr = index * 1u;
    return adr;
}

bool free(uint level, uint adr)
{
    uint index = adr / 1u;
    if (bucket == 3735928559u)
    {
        bucket = adr;
        return true;
    }
    uint param = level;
    uint param_1 = index;
    uint param_2 = 3u;
    bool _2266 = try_free(param, param_1, param_2);
    return _2266;
}

float3 get_col(uint val, inout uint x, inout uint y)
{
    uint scale = 8u;
    x /= scale;
    y /= scale;
    uint pos = (x / 5u) % 10u;
    uint p_x = 4u - (x % 5u);
    uint p_y = y % 6u;
    uint dig;
    if (pos <= 7u)
    {
        dig = (val >> (pos * 4u)) & 15u;
    }
    else
    {
        if (pos == 8u)
        {
            dig = 16u;
        }
        else
        {
            dig = 17u;
        }
    }
    bool on = ((num_sprites[dig] >> (31u - (p_x + (5u * p_y)))) & 1u) == 1u;
    return float3(float(on), float(on), float(on));
}

void galloc_finalize()
{
    uint adr = bucket;
    uint index = adr / 1u;
    if (bucket != 3735928559u)
    {
        uint param = 1u;
        uint param_1 = index;
        uint param_2 = 3u;
        bool _2323 = try_free(param, param_1, param_2);
    }
}

void comp_main()
{
    _log_overflow = false;
    _current_chunk = 3735928559u;
    _log_pos = 32u;
    uint_to_exact_table = 2340u;
    all_locked_treelet = 156411210u;
    all_free_treelet = 135274560u;
    actually_alloced = false;
    bucket = 3735928559u;
    last = 0u;
    last_succ_adr = 0u;
    fail_count = 1u;
    na_hash = 0u;
    num_sprites = _273;
    galloc_initialize();
    if (gl_LocalInvocationIndex == 0u)
    {
        no_unroll_shared = min(no_unroll.Load(0), 0u);
    }
    GroupMemoryBarrierWithGroupSync();
    uint3 sWG = gl_WorkGroupSize;
    uint3 nWG = SPIRV_Cross_NumWorkgroups_1_count;
    uint3 gID = gl_GlobalInvocationID;
    uint item_count = ((sWG.x * sWG.y) * sWG.z) * ((nWG.x * nWG.y) * nWG.z);
    uint item_id = (gID.x + ((gID.y * sWG.x) * nWG.x)) + ((((gID.z * sWG.x) * nWG.x) * sWG.y) * nWG.y);
    uint ray_count = trace[(0)/4] * trace[(4)/4];
    if (any(bool4(asfloat(uint4(trace[(16)/4],trace[(16)/4+1],trace[(16)/4+2],trace[(16)/4+3])).x <= 0.0f.xxxx.x, asfloat(uint4(trace[(16)/4],trace[(16)/4+1],trace[(16)/4+2],trace[(16)/4+3])).y <= 0.0f.xxxx.y, asfloat(uint4(trace[(16)/4],trace[(16)/4+1],trace[(16)/4+2],trace[(16)/4+3])).z <= 0.0f.xxxx.z, asfloat(uint4(trace[(16)/4],trace[(16)/4+1],trace[(16)/4+2],trace[(16)/4+3])).w <= 0.0f.xxxx.w)))
    {
        color_texture[int2(int(item_id), int(item_id))] = float4(1.0f, 0.0f, 0.0f, 1.0f);
        return;
    }
    else
    {
        if (uniforms_bad())
        {
            color_texture[int2(int(item_id), int(item_id))] = float4(0.0f, 1.0f, 0.0f, 1.0f);
            return;
        }
        else
        {
            if (item_count <= 0u)
            {
                color_texture[int2(int(item_id), int(item_id))] = float4(0.0f, 0.0f, 1.0f, 1.0f);
                return;
            }
        }
    }
    float3 color;
    while (item_id < ray_count)
    {
        int2 gid_2d = int2(int(item_id % trace[(0)/4]), int(item_id / trace[(0)/4]));
        int2 pix_pos = gid_2d - (int2(uint2(trace[(0)/4],trace[(0)/4+1])) / int2(2, 2));
        float2 view_pos = float2(pix_pos) / (float2(uint2(trace[(0)/4],trace[(0)/4+1])) / 2.0f.xx);
        float dist = length(float2(pix_pos));
        uint ptr_l = 0u;
        float res = 1.0f;
        bool good_free = true;
        bool freeness = false;
        int i = 0;
        while (i < 1)
        {
            uint param = 1u;
            uint _2604 = alloc(param);
            ptr_l = _2604;
            if (ptr_l == 3735928559u)
            {
                i = 8;
            }
            else
            {
                uint param_1 = 1u;
                uint param_2 = ptr_l;
                bool _2613 = free(param_1, param_2);
                freeness = _2613;
                good_free = good_free || freeness;
                res *= 2.0f;
            }
            i++;
        }
        float3 true_up = float3(0.0f, 1.0f, 0.0f);
        float3 right = normalize(cross(true_up, asfloat(uint3(trace[(48)/4],trace[(48)/4+1],trace[(48)/4+2]))));
        float3 up = normalize(cross(asfloat(uint3(trace[(48)/4],trace[(48)/4+1],trace[(48)/4+2])), right));
        float3 pos = (((right * asfloat(trace[(16)/4])) * view_pos.x) + ((up * asfloat(trace[(20)/4])) * view_pos.y)) + (asfloat(uint3(trace[(48)/4],trace[(48)/4+1],trace[(48)/4+2])) * asfloat(trace[(24)/4]));
        float3 dir = normalize(pos);
        pos += asfloat(uint3(trace[(32)/4],trace[(32)/4+1],trace[(32)/4+2]));
        float depth = 0.0f;
        float fade = 1.0f;
        uint steps = 0u;
        uint step_lim = trace[(60)/4];
        steps = 0u;
        for (; steps < step_lim; steps++)
        {
            float3 m_pos = (frac((pos + 6.0f.xxx) / 12.0f.xxx) * 12.0f) - 6.0f.xxx;
            if (length(m_pos) < 5.0f)
            {
                color = normalize(abs(m_pos)) * fade;
                break;
            }
            else
            {
                float step_size = (length(m_pos) - 4.900000095367431640625f) * 0.949999988079071044921875f;
                depth += step_size;
                pos += (dir * step_size);
                fade *= 0.99500000476837158203125f;
            }
        }
        if (steps == trace[(60)/4])
        {
            color = 0.0f.xxx;
        }
        if (!good_free)
        {
            color = float3(1.0f, 0.0f, 1.0f);
        }
        if (geom[(8)/4] == 3735928559u)
        {
            color = float3(0.0f, 0.100000001490116119384765625f, 0.100000001490116119384765625f);
        }
        uint2 p_pos = uint2(0u, trace[(4)/4]) - uint2(gid_2d);
        uint param_3 = geom[(8)/4];
        uint param_4 = p_pos.x;
        uint param_5 = p_pos.y;
        float3 _2767 = get_col(param_3, param_4, param_5);
        color += _2767;
        color = (color * (30.0f - float(last_fail_count))) / 30.0f.xxx;
        depth /= (asfloat(trace[(28)/4]) - asfloat(trace[(24)/4]));
        int2 gid_2d_i = gid_2d;
        float4 old_depth_1 = old_depth.Load(int3(gid_2d_i, 0));
        old_depth_1.x /= (asfloat(trace[(28)/4]) - (old_depth_1.x * (asfloat(trace[(28)/4]) - asfloat(trace[(24)/4]))));
        float4 old_color = color_texture[gid_2d];
        if (depth < old_depth_1.x)
        {
            color_texture[gid_2d] = float4(color, 1.0f);
        }
        else
        {
            color_texture[gid_2d] = old_color;
        }
        item_id += item_count;
    }
    galloc_finalize();
}

[numthreads(8, 8, 1)]
void main(SPIRV_Cross_Input stage_input)
{
    gl_GlobalInvocationID = stage_input.gl_GlobalInvocationID;
    gl_LocalInvocationIndex = stage_input.gl_LocalInvocationIndex;
    comp_main();
}
