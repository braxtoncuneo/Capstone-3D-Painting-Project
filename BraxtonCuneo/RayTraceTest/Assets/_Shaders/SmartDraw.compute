#pragma kernel main

static const uint3 gl_WorkGroupSize = uint3(8u, 8u, 1u);

struct _2622
{
    uint data[124];
};

struct _2964
{
    uint data[124];
};

static const uint _3241[32] = { 20u, 8u, 9u, 19u, 27u, 9u, 19u, 27u, 1u, 27u, 20u, 8u, 9u, 18u, 20u, 25u, 27u, 20u, 23u, 15u, 27u, 3u, 8u, 1u, 18u, 27u, 17u, 21u, 15u, 20u, 5u, 0u };
static const uint _3243[10] = { 2u, 1u, 4u, 27u, 1u, 12u, 12u, 15u, 3u, 0u };
static const uint _3245[9] = { 2u, 1u, 4u, 27u, 6u, 18u, 5u, 5u, 0u };

RWStructuredBuffer<uint> no_unroll  : register(u7); 
RWStructuredBuffer<uint> mem_man  : register(u2); 
RWStructuredBuffer<uint> geom  : register(u4); 
RWStructuredBuffer<uint> data  : register(u1); 
RWStructuredBuffer<uint> task  : register(u3); 
RWStructuredBuffer<uint> draw  : register(u5); 
RWStructuredBuffer<uint> debug_log  : register(u0); 
cbuffer SPIRV_Cross_NumWorkgroups : register(b0)
{
    uint3 SPIRV_Cross_NumWorkgroups_1_count : packoffset(c0);
};


static uint3 gl_GlobalInvocationID;
static uint gl_LocalInvocationIndex;
struct SPIRV_Cross_Input
{
    uint3 gl_GlobalInvocationID : SV_DispatchThreadID;
    uint gl_LocalInvocationIndex : SV_GroupIndex;
};

static bool _log_overflow;
static uint _current_chunk;
static uint _log_pos;
static uint uint_to_exact_table;
static bool actually_alloced;
static uint bucket;
static uint last;
static uint last_succ_adr;
static uint fail_count;
static uint na_hash;
static uint task_op_hash;
static uint last_good_op_index;
static uint local_ready_active;
static bool has_worked;
static uint log_idx;
groupshared uint no_unroll_shared;
static uint last_modify;
static uint fail_level;
static uint last_fail_count;
static uint gid;
groupshared uint passes;
groupshared uint bucket_level;
groupshared uint task_bucket_count;
groupshared _2622 task_bucket;
groupshared bool should_wait;
groupshared bool should_exit;
groupshared uint last_bucket_level;
groupshared uint active_link;
groupshared bool currently_active;
groupshared uint tasks_to_process;
groupshared _2964 current_task;
static uint _charbuff[5];
static uint hmm;
groupshared uint tasks_to_relocate;

uint _430;
uint _818;
uint _898;
uint _978;
uint _1036;
uint _1124;
uint _1181;

void INIT_NO_UNROLL()
{
    no_unroll_shared = min(no_unroll[(0)/4], 1u);
}

void galloc_initialize()
{
    uint3 sWG = gl_WorkGroupSize;
    uint3 nWG = SPIRV_Cross_NumWorkgroups_1_count;
    uint3 gID = gl_GlobalInvocationID;
    uint item_id = (gID.x + ((gID.y * sWG.x) * nWG.x)) + ((((gID.z * sWG.x) * nWG.x) * sWG.y) * nWG.y);
    gid = item_id;
    last = gid;
}

uint FNV1_a_hash_combine(uint old_hash, uint val)
{
    uint h = old_hash;
    for (uint i = 0u; i < 4u; i++)
    {
        h ^= (val & 255u);
        h *= 16777619u;
        h = h >> uint(8);
    }
    return h;
}

uint next_alloc_idx(uint level)
{
    uint level_mag = 1u << level;
    uint adr_mask = 65535u & (~(level_mag - 1u));
    uint param = na_hash;
    uint param_1 = last + last_succ_adr;
    na_hash = FNV1_a_hash_combine(param, param_1) - 1u;
    uint hash_offset = (na_hash & 7u) + 1u;
    last = ((last + (((fail_count * fail_count) * level_mag) * hash_offset)) + uint(1 << int(fail_level))) & adr_mask;
    last_fail_count = fail_count;
    return last;
}

uint NO_UNROLL(uint lim)
{
    return lim * (no_unroll_shared + 1u);
}

void break_index(inout uint index, inout uint level, inout uint tier, out uint subtier, out uint t_index, out uint l_index, out uint lowest_bit, inout bool is_lowest)
{
    is_lowest = level == 0u;
    lowest_bit = 0u;
    if (is_lowest)
    {
        lowest_bit = index & 1u;
    }
    else
    {
        level--;
    }
    index = index >> 1u;
    tier = level / 4u;
    uint tier_levs = tier * 4u;
    subtier = level - tier_levs;
    uint s_index = index >> tier_levs;
    uint level_index_mask = 7u;
    l_index = s_index & level_index_mask;
    t_index = s_index >> 3u;
}

uint tier_offset(inout uint tier)
{
    tier = 3u - tier;
    if (tier == 0u)
    {
        return 0u;
    }
    return ((1u << (tier * 4u)) - 1u) / 15u;
}

uint from_triple(uint t)
{
    return 15u & (2258383380u >> (t * 4u));
}

void decode_double_partial(uint leaflet, out uint left, out uint right)
{
    uint param = 7u & leaflet;
    right = from_triple(param);
    uint param_1 = 7u & (leaflet >> uint(3));
    left = from_triple(param_1);
}

void decode_range(uint leaflet, out uint result)
{
    uint code = leaflet;
    if ((code & 12u) == 12u)
    {
        result = 17u + (code & 3u);
    }
    else
    {
        result = 21u + ((code >> uint(2)) & 3u);
    }
}

void decode_double_exact(uint leaflet, out uint left, out uint right)
{
    uint code = leaflet - 64u;
    left = (code << uint(2)) & 48u;
    right = (code << uint(4)) & 48u;
}

void decode_single_exact(uint leaflet, out uint left, out uint right)
{
    uint code = (leaflet - 80u) >> uint(3);
    uint exact_code = ((uint_to_exact_table >> (code * 2u)) & 3u) << uint(4);
    if (code < 3u)
    {
        left = exact_code;
        uint param = leaflet & 7u;
        right = from_triple(param);
    }
    else
    {
        right = exact_code;
        uint param_1 = leaflet & 7u;
        left = from_triple(param_1);
    }
}

void read_leaflet(uint treelet, uint index, inout uint left, out uint right)
{
    uint leaflet = 127u & (treelet >> (7u * index));
    if (leaflet < 64u)
    {
        uint param = leaflet;
        uint param_1;
        uint param_2;
        decode_double_partial(param, param_1, param_2);
        left = param_1;
        right = param_2;
    }
    else
    {
        if (leaflet < 80u)
        {
            bool _583 = (leaflet & 3u) == 3u;
            bool _590;
            if (!_583)
            {
                _590 = (leaflet & 12u) == 12u;
            }
            else
            {
                _590 = _583;
            }
            if (_590)
            {
                uint param_3 = leaflet;
                uint param_4;
                decode_range(param_3, param_4);
                left = param_4;
                right = left;
            }
            else
            {
                uint param_5 = leaflet;
                uint param_6;
                uint param_7;
                decode_double_exact(param_5, param_6, param_7);
                left = param_6;
                right = param_7;
            }
        }
        else
        {
            uint param_8 = leaflet;
            uint param_9;
            uint param_10;
            decode_single_exact(param_8, param_9, param_10);
            left = param_9;
            right = param_10;
        }
    }
}

bool all_locked_or_free(uint treelet)
{
    uint mask = 19u;
    uint i = 0u;
    uint left;
    uint right;
    for (;;)
    {
        uint param = 4u;
        uint _689 = NO_UNROLL(param);
        if (i < _689)
        {
            uint param_1 = treelet;
            uint param_2 = i;
            uint param_3 = left;
            uint param_4 = right;
            read_leaflet(param_1, param_2, param_3, param_4);
            left = param_3;
            right = param_4;
            bool _707 = (left & mask) != 0u;
            bool _715;
            if (!_707)
            {
                _715 = (right & mask) != 0u;
            }
            else
            {
                _715 = _707;
            }
            if (_715)
            {
                return false;
            }
            i++;
            continue;
        }
        else
        {
            break;
        }
    }
    return true;
}

uint encode_range(uint leaflet)
{
    uint code = leaflet - 17u;
    if (code < 4u)
    {
        return (64u + code) | 12u;
    }
    else
    {
        return (64u + ((code - 4u) << uint(2))) | 3u;
    }
}

uint encode_double_exact(uint left, uint right)
{
    uint code = (left >> uint(2)) | (right >> uint(4));
    return code + 64u;
}

uint to_triple(inout uint t)
{
    uint chunk = 4142936607u;
    if (t >= 8u)
    {
        chunk = 4294246231u;
        t -= 8u;
    }
    return 15u & (chunk >> (t * 4u));
}

uint encode_single_exact(uint left, uint right)
{
    uint code;
    uint part;
    if ((left & 15u) == 0u)
    {
        code = left >> uint(4);
        uint param = right;
        uint _543 = to_triple(param);
        part = _543;
    }
    else
    {
        code = 3u + (right >> uint(4));
        uint param_1 = left;
        uint _550 = to_triple(param_1);
        part = _550;
    }
    return ((code << uint(3)) + 80u) | part;
}

uint encode_double_partial(uint left, uint right)
{
    uint param = left;
    uint _383 = to_triple(param);
    uint param_1 = right;
    uint _387 = to_triple(param_1);
    return (_383 << uint(3)) | _387;
}

uint write_leaflet(inout uint treelet, uint index, uint left, uint right)
{
    uint lower_count = uint((left & 15u) != 0u) + uint((right & 15u) != 0u);
    uint leaflet;
    if ((left >= 17u) && (left != 32u))
    {
        uint param = left;
        leaflet = encode_range(param);
    }
    else
    {
        if (lower_count == 0u)
        {
            uint param_1 = left;
            uint param_2 = right;
            leaflet = encode_double_exact(param_1, param_2);
        }
        else
        {
            if (lower_count == 1u)
            {
                uint param_3 = left;
                uint param_4 = right;
                leaflet = encode_single_exact(param_3, param_4);
            }
            else
            {
                uint param_5 = left;
                uint param_6 = right;
                leaflet = encode_double_partial(param_5, param_6);
            }
        }
    }
    treelet &= uint(~(127 << int(7u * index)));
    treelet |= (leaflet << (7u * index));
    return treelet;
}

uint part_alloc(uint treelet, uint index, inout uint succ)
{
    uint leaflet_idx = index >> 2u;
    uint pos = (index & 2u) >> uint(1);
    uint pos2 = index & 1u;
    uint w_mask = uint(1 << int(pos2));
    uint t_mask = 48u | w_mask;
    uint param = treelet;
    uint param_1 = leaflet_idx;
    uint left;
    uint param_2 = left;
    uint right;
    uint param_3 = right;
    read_leaflet(param, param_1, param_2, param_3);
    left = param_2;
    right = param_3;
    uint val = left;
    if (pos == 0u)
    {
        val = right;
    }
    if ((val & t_mask) == 0u)
    {
        if ((val & (w_mask << 2u)) == 0u)
        {
            actually_alloced = true;
        }
        else
        {
            actually_alloced = false;
        }
        val &= (~(w_mask << 2u));
        val |= w_mask;
        if (pos == 0u)
        {
            right = val;
        }
        else
        {
            left = val;
        }
        uint param_4 = treelet;
        succ = uint(!all_locked_or_free(param_4));
        uint param_5 = treelet;
        uint param_6 = leaflet_idx;
        uint param_7 = left;
        uint param_8 = right;
        uint _808 = write_leaflet(param_5, param_6, param_7, param_8);
        return _808;
    }
    else
    {
        actually_alloced = false;
        succ = uint((val & 48u) != 0u) + 1u;
        return treelet;
    }
}

uint retry_modify(uint idx, uint new_value, inout uint old_value)
{
    if (new_value == old_value)
    {
        return 0u;
    }
    uint _1407;
    InterlockedCompareExchange(mem_man[(idx * 4 + 4)/4], old_value, new_value, _1407);
    uint swap = _1407;
    uint result = uint((swap == old_value) ? 0 : 2);
    if (swap == old_value)
    {
        old_value = new_value;
        last_modify = new_value;
    }
    else
    {
        old_value = swap;
        last_modify = swap;
    }
    return result;
}

uint try_part_alloc(uint tier, uint tier_index, uint local_index)
{
    uint param = tier;
    uint _1431 = tier_offset(param);
    uint true_index = tier_index + _1431;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint succ = 0u;
    uint ch_succ = 2u;
    uint param_3;
    while ((succ != 2u) && (ch_succ == 2u))
    {
        uint true_old = old_treelet;
        uint param_1 = old_treelet;
        uint param_2 = local_index;
        uint _1457 = part_alloc(param_1, param_2, param_3);
        succ = param_3;
        uint new_treelet = _1457;
        if (succ != 2u)
        {
            uint param_4 = true_index;
            uint param_5 = new_treelet;
            uint param_6 = old_treelet;
            uint _1470 = retry_modify(param_4, param_5, param_6);
            old_treelet = param_6;
            ch_succ = max(succ, _1470);
        }
    }
    return ch_succ;
}

uint leaf_alloc(uint treelet, uint index, inout uint succ)
{
    uint leaflet_idx = index >> 1u;
    uint pos = index & 1u;
    uint param = treelet;
    uint param_1 = leaflet_idx;
    uint left;
    uint param_2 = left;
    uint right;
    uint param_3 = right;
    read_leaflet(param, param_1, param_2, param_3);
    left = param_2;
    right = param_3;
    uint val = left;
    if (pos == 0u)
    {
        val = right;
    }
    if ((val & 63u) == 0u)
    {
        if (pos == 0u)
        {
            right = 16u;
        }
        else
        {
            left = 16u;
        }
        uint param_4 = treelet;
        uint param_5 = leaflet_idx;
        uint param_6 = left;
        uint param_7 = right;
        uint _1025 = write_leaflet(param_4, param_5, param_6, param_7);
        uint new_treelet = _1025;
        uint param_8 = treelet;
        succ = uint(!all_locked_or_free(param_8));
        return new_treelet;
    }
    else
    {
        succ = 2u;
        return treelet;
    }
}

bool all_free(uint treelet)
{
    return treelet == 135274560u;
}

uint write_range(uint treelet, uint level, uint index, uint val)
{
    uint scale = uint(1 << int(level));
    uint start = index;
    uint lim = start + scale;
    uint head = treelet >> (lim * 7u);
    uint tail = treelet & uint((1 << int(start * 7u)) - 1);
    uint result = head;
    for (uint i = index; i < lim; i++)
    {
        result = result << 7u;
        result |= val;
    }
    result = result << (start * 7u);
    result |= tail;
    return result;
}

uint range_alloc(uint treelet, inout uint level, uint index, inout uint succ)
{
    uint param = 17u + level;
    uint val = encode_range(param);
    level--;
    uint lim = uint(1 << int(level));
    uint i = 0u;
    uint left;
    uint right;
    for (;;)
    {
        uint param_1 = lim;
        uint _1202 = NO_UNROLL(param_1);
        if (i < _1202)
        {
            uint param_2 = treelet;
            uint param_3 = index + i;
            uint param_4 = left;
            uint param_5 = right;
            read_leaflet(param_2, param_3, param_4, param_5);
            left = param_4;
            right = param_5;
            if ((left != 0u) || (right != 0u))
            {
                succ = 2u;
                return treelet;
            }
            i++;
            continue;
        }
        else
        {
            break;
        }
    }
    uint param_6 = treelet;
    succ = uint(!all_free(param_6));
    uint param_7 = treelet;
    uint param_8 = level;
    uint param_9 = index;
    uint param_10 = val;
    return write_range(param_7, param_8, param_9, param_10);
}

uint try_modify(uint idx, uint new_value, uint old_value)
{
    if (new_value == old_value)
    {
        return 0u;
    }
    uint _1379;
    InterlockedCompareExchange(mem_man[(idx * 4 + 4)/4], old_value, new_value, _1379);
    uint swap = _1379;
    if (swap == old_value)
    {
        last_modify = new_value;
    }
    else
    {
        last_modify = swap;
    }
    return uint((swap == old_value) ? 0 : 2);
}

uint try_base_alloc(uint true_index, uint subtier, uint level_index)
{
    uint succ = 2u;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint new_treelet;
    if (subtier == 0u)
    {
        uint param = old_treelet;
        uint param_1 = level_index;
        uint param_2;
        uint _1689 = leaf_alloc(param, param_1, param_2);
        succ = param_2;
        new_treelet = _1689;
    }
    else
    {
        uint param_3 = old_treelet;
        uint param_4 = subtier;
        uint param_5 = level_index >> uint(1);
        uint param_6;
        uint _1700 = range_alloc(param_3, param_4, param_5, param_6);
        succ = param_6;
        new_treelet = _1700;
    }
    if (succ == 2u)
    {
        return succ;
    }
    uint param_7 = true_index;
    uint param_8 = new_treelet;
    uint param_9 = old_treelet;
    uint _1715 = try_modify(param_7, param_8, param_9);
    return max(succ, _1715);
}

void print_treelet(uint treelet)
{
}

void level_up_index(inout uint tier_index, out uint level_index)
{
    level_index = tier_index & 15u;
    tier_index = tier_index >> 4u;
}

uint part_lock(inout uint treelet, uint index, inout uint succ)
{
    uint leaflet_idx = index >> 2u;
    uint pos = (index & 2u) >> uint(1);
    uint pos2 = index & 1u;
    uint t_mask = uint(1 << int(pos2));
    uint w_mask = t_mask << uint(2);
    uint param = treelet;
    uint param_1 = leaflet_idx;
    uint left;
    uint param_2 = left;
    uint right;
    uint param_3 = right;
    read_leaflet(param, param_1, param_2, param_3);
    left = param_2;
    right = param_3;
    uint val = left;
    if (pos == 0u)
    {
        val = right;
    }
    if (((val & t_mask) != 0u) && (val < 16u))
    {
        val &= (~t_mask);
        val |= w_mask;
        if (pos == 0u)
        {
            right = val;
        }
        else
        {
            left = val;
        }
        uint param_4 = treelet;
        uint param_5 = leaflet_idx;
        uint param_6 = left;
        uint param_7 = right;
        uint _967 = write_leaflet(param_4, param_5, param_6, param_7);
        treelet = _967;
        uint param_8 = treelet;
        succ = uint(!all_locked_or_free(param_8));
        return treelet;
    }
    else
    {
        succ = 2u;
        return treelet;
    }
}

uint try_part_lock(uint tier, uint tier_index, uint local_index)
{
    uint param = tier;
    uint _1480 = tier_offset(param);
    uint true_index = tier_index + _1480;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint succ = 0u;
    uint ch_succ = 2u;
    uint param_3;
    while ((succ != 2u) && (ch_succ == 2u))
    {
        uint param_1 = old_treelet;
        uint param_2 = local_index;
        uint _1504 = part_lock(param_1, param_2, param_3);
        succ = param_3;
        uint new_treelet = _1504;
        if (succ != 2u)
        {
            uint param_4 = true_index;
            uint param_5 = new_treelet;
            uint param_6 = old_treelet;
            uint _1517 = retry_modify(param_4, param_5, param_6);
            old_treelet = param_6;
            ch_succ = max(succ, _1517);
        }
    }
    if (ch_succ != 2u)
    {
    }
    return ch_succ;
}

uint part_free(inout uint treelet, uint index, inout uint succ)
{
    uint leaflet_idx = index >> 2u;
    uint pos = (index & 2u) >> 1u;
    uint pos2 = index & 1u;
    uint mask = uint(4 << int(pos2));
    uint param = treelet;
    uint param_1 = leaflet_idx;
    uint left;
    uint param_2 = left;
    uint right;
    uint param_3 = right;
    read_leaflet(param, param_1, param_2, param_3);
    left = param_2;
    right = param_3;
    uint val = left;
    if (pos == 0u)
    {
        val = right;
    }
    if (((val & mask) != 0u) && (val < 16u))
    {
        val &= (~mask);
        if (pos == 0u)
        {
            right = val;
        }
        else
        {
            left = val;
        }
        uint param_4 = treelet;
        uint param_5 = leaflet_idx;
        uint param_6 = left;
        uint param_7 = right;
        uint _882 = write_leaflet(param_4, param_5, param_6, param_7);
        treelet = _882;
        uint param_8 = treelet;
        succ = uint(!all_free(param_8));
        if (succ == 0u)
        {
            treelet = 156411210u;
        }
        return treelet;
    }
    else
    {
        succ = 2u;
        return treelet;
    }
}

uint try_part_free(uint tier, uint tier_index, uint local_index)
{
    uint param = tier;
    uint _1629 = tier_offset(param);
    uint true_index = tier_index + _1629;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint succ = 0u;
    uint ch_succ = 2u;
    uint param_3;
    while ((succ != 2u) && (ch_succ == 2u))
    {
        uint true_old = old_treelet;
        uint param_1 = old_treelet;
        uint param_2 = local_index;
        uint _1655 = part_free(param_1, param_2, param_3);
        succ = param_3;
        uint new_treelet = _1655;
        if (succ != 2u)
        {
            uint param_4 = true_index;
            uint param_5 = new_treelet;
            uint param_6 = old_treelet;
            uint _1668 = retry_modify(param_4, param_5, param_6);
            old_treelet = param_6;
            ch_succ = max(succ, _1668);
        }
    }
    return ch_succ;
}

uint leaf_free(uint treelet, uint index, inout uint succ)
{
    uint leaflet_idx = index >> 1u;
    uint pos = index & 1u;
    uint param = treelet;
    uint param_1 = leaflet_idx;
    uint left;
    uint param_2 = left;
    uint right;
    uint param_3 = right;
    read_leaflet(param, param_1, param_2, param_3);
    left = param_2;
    right = param_3;
    uint val = left;
    if (pos == 0u)
    {
        val = right;
    }
    if (val == 16u)
    {
        if (pos == 0u)
        {
            right = 0u;
        }
        else
        {
            left = 0u;
        }
        uint param_4 = treelet;
        uint param_5 = leaflet_idx;
        uint param_6 = left;
        uint param_7 = right;
        uint _1169 = write_leaflet(param_4, param_5, param_6, param_7);
        uint new_treelet = _1169;
        uint param_8 = new_treelet;
        if (all_free(param_8))
        {
            succ = 0u;
            new_treelet = 156411210u;
        }
        else
        {
            succ = 1u;
        }
        return new_treelet;
    }
    else
    {
        succ = 2u;
        return treelet;
    }
}

uint range_free(uint treelet, inout uint level, uint index, inout uint succ)
{
    uint param = 0u;
    uint param_1 = 0u;
    uint val = encode_double_exact(param, param_1);
    uint test = 17u + level;
    level--;
    uint lim = 1u << level;
    uint i = 0u;
    uint left;
    uint right;
    for (;;)
    {
        uint param_2 = lim;
        uint _1267 = NO_UNROLL(param_2);
        if (i < _1267)
        {
            uint param_3 = treelet;
            uint param_4 = index + i;
            uint param_5 = left;
            uint param_6 = right;
            read_leaflet(param_3, param_4, param_5, param_6);
            left = param_5;
            right = param_6;
            if ((left != test) || (right != test))
            {
                succ = 2u;
                return treelet;
            }
            i++;
            continue;
        }
        else
        {
            break;
        }
    }
    uint param_7 = treelet;
    uint param_8 = level;
    uint param_9 = index;
    uint param_10 = val;
    uint new_treelet = write_range(param_7, param_8, param_9, param_10);
    uint param_11 = new_treelet;
    if (all_free(param_11))
    {
        succ = 0u;
        new_treelet = 156411210u;
    }
    else
    {
        succ = 1u;
    }
    return new_treelet;
}

uint try_base_free(uint true_index, uint subtier, uint level_index)
{
    uint succ = 0u;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint ch_succ = 2u;
    uint new_treelet;
    if (subtier == 0u)
    {
        uint param_2;
        while ((succ != 2u) && (ch_succ == 2u))
        {
            uint param = old_treelet;
            uint param_1 = level_index;
            uint _1745 = leaf_free(param, param_1, param_2);
            succ = param_2;
            new_treelet = _1745;
            if (succ != 2u)
            {
                uint param_3 = true_index;
                uint param_4 = new_treelet;
                uint param_5 = old_treelet;
                uint _1758 = retry_modify(param_3, param_4, param_5);
                old_treelet = param_5;
                ch_succ = max(succ, _1758);
            }
        }
    }
    else
    {
        uint param_9;
        while ((succ != 2u) && (ch_succ == 2u))
        {
            uint param_6 = old_treelet;
            uint param_7 = subtier;
            uint param_8 = level_index >> uint(1);
            uint _1780 = range_free(param_6, param_7, param_8, param_9);
            succ = param_9;
            new_treelet = _1780;
            if (succ != 2u)
            {
                uint param_10 = true_index;
                uint param_11 = new_treelet;
                uint param_12 = old_treelet;
                uint _1793 = retry_modify(param_10, param_11, param_12);
                old_treelet = param_12;
                ch_succ = max(succ, _1793);
            }
        }
    }
    if (succ != 2u)
    {
    }
    return ch_succ;
}

uint try_resolve(uint tier, uint tier_index)
{
    uint param = tier;
    uint _1580 = tier_offset(param);
    uint true_index = tier_index + _1580;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint succ = 0u;
    uint ch_succ = 2u;
    uint new_treelet;
    while ((succ != 2u) && (ch_succ == 2u))
    {
        if (old_treelet == 156411210u)
        {
            succ = 0u;
            new_treelet = 135274560u;
        }
        else
        {
            uint param_1 = old_treelet;
            print_treelet(param_1);
            succ = 1u;
            new_treelet = old_treelet;
        }
        if (succ != 2u)
        {
            uint param_2 = true_index;
            uint param_3 = new_treelet;
            uint param_4 = old_treelet;
            uint _1619 = retry_modify(param_2, param_3, param_4);
            old_treelet = param_4;
            ch_succ = max(succ, _1619);
        }
    }
    return ch_succ;
}

uint upward_free(uint treelet, uint part_index, inout uint succ)
{
    uint part_pos = part_index & 1u;
    uint index = part_index >> 1u;
    uint leaflet_idx = index >> 1u;
    uint pos = index & 1u;
    uint mask = uint(4 << int(part_pos));
    uint param = treelet;
    uint param_1 = leaflet_idx;
    uint left;
    uint param_2 = left;
    uint right;
    uint param_3 = right;
    read_leaflet(param, param_1, param_2, param_3);
    left = param_2;
    right = param_3;
    uint val = left;
    if (pos == 0u)
    {
        val = right;
    }
    if (val == 0u)
    {
        succ = 1u;
        return treelet;
    }
    else
    {
        bool _1081 = val < 16u;
        bool _1088;
        if (_1081)
        {
            _1088 = (val & mask) != 0u;
        }
        else
        {
            _1088 = _1081;
        }
        if (_1088)
        {
            uint new_val = val & (~mask);
            if (pos == 0u)
            {
                right = new_val;
            }
            else
            {
                left = new_val;
            }
            uint param_4 = treelet;
            uint param_5 = leaflet_idx;
            uint param_6 = left;
            uint param_7 = right;
            uint _1112 = write_leaflet(param_4, param_5, param_6, param_7);
            uint new_treelet = _1112;
            uint param_8 = new_treelet;
            if (all_free(param_8))
            {
                new_treelet = 156411210u;
                succ = 0u;
            }
            else
            {
                succ = 1u;
            }
            return new_treelet;
        }
        else
        {
            succ = 1u;
            return treelet;
        }
    }
}

uint try_upward_free(uint tier, uint tier_index, uint local_index)
{
    uint param = tier;
    uint _1531 = tier_offset(param);
    uint true_index = tier_index + _1531;
    uint old_treelet = mem_man[(true_index * 4 + 4)/4];
    uint succ = 0u;
    uint ch_succ = 2u;
    uint param_3;
    while ((succ != 2u) && (ch_succ == 2u))
    {
        uint true_old = old_treelet;
        uint param_1 = old_treelet;
        uint param_2 = local_index;
        uint _1557 = upward_free(param_1, param_2, param_3);
        succ = param_3;
        uint new_treelet = _1557;
        if (succ != 2u)
        {
            uint param_4 = true_index;
            uint param_5 = new_treelet;
            uint param_6 = old_treelet;
            uint _1570 = retry_modify(param_4, param_5, param_6);
            old_treelet = param_6;
            ch_succ = max(succ, _1570);
        }
    }
    return ch_succ;
}

bool try_free(inout uint level, inout uint index, uint top_tier)
{
    uint param = index;
    uint param_1 = level;
    uint param_2;
    uint param_3;
    uint param_4;
    uint param_5;
    uint param_6;
    bool param_7;
    break_index(param, param_1, param_2, param_3, param_4, param_5, param_6, param_7);
    index = param;
    level = param_1;
    uint tier = param_2;
    uint subtier = param_3;
    uint tier_index = param_4;
    uint level_index = param_5;
    uint lowest_bit = param_6;
    bool is_lowest = param_7;
    uint last_tier_index = tier_index;
    uint last_level_index = level_index;
    uint param_8 = tier_index;
    uint param_9 = level_index;
    level_up_index(param_8, param_9);
    tier_index = param_8;
    level_index = param_9;
    uint param_10 = tier;
    uint _1843 = tier_offset(param_10);
    uint true_index = last_tier_index + _1843;
    uint succ;
    if (is_lowest)
    {
        uint param_11 = 0u;
        uint param_12 = last_tier_index;
        uint param_13 = (last_level_index * 2u) + lowest_bit;
        uint _1857 = try_part_lock(param_11, param_12, param_13);
        succ = _1857;
        uint param_14 = last_modify;
        print_treelet(param_14);
        uint param_15 = 0u;
        uint param_16 = last_tier_index;
        uint param_17 = (last_level_index * 2u) + lowest_bit;
        uint _1869 = try_part_free(param_15, param_16, param_17);
        succ = _1869;
        uint param_18 = last_modify;
        print_treelet(param_18);
    }
    else
    {
        uint param_19 = true_index;
        uint param_20 = subtier;
        uint param_21 = last_level_index;
        uint _1880 = try_base_free(param_19, param_20, param_21);
        succ = _1880;
        uint param_22 = last_modify;
        print_treelet(param_22);
    }
    if (succ == 2u)
    {
        return false;
    }
    else
    {
        if (succ == 1u)
        {
            return true;
        }
    }
    uint parent_succ;
    if (tier < top_tier)
    {
        uint param_23 = tier + 1u;
        uint param_24 = tier_index;
        uint param_25 = level_index;
        uint _1908 = try_part_lock(param_23, param_24, param_25);
        parent_succ = _1908;
        uint param_26 = last_modify;
        print_treelet(param_26);
    }
    if (succ == 2u)
    {
        return false;
    }
    else
    {
        if (succ == 1u)
        {
            return true;
        }
    }
    uint param_27 = tier;
    uint param_28 = last_tier_index;
    uint _1927 = try_resolve(param_27, param_28);
    succ = _1927;
    uint param_29 = last_modify;
    print_treelet(param_29);
    if (succ == 2u)
    {
        return false;
    }
    else
    {
        if (succ == 1u)
        {
            return true;
        }
    }
    if (parent_succ == 2u)
    {
        return false;
    }
    uint climb_tier = tier + 1u;
    for (;;)
    {
        uint param_30 = top_tier;
        uint _1958 = NO_UNROLL(param_30);
        if (climb_tier < _1958)
        {
            last_tier_index = tier_index;
            last_level_index = level_index;
            uint param_31 = tier_index;
            uint param_32 = level_index;
            level_up_index(param_31, param_32);
            tier_index = param_31;
            level_index = param_32;
            uint param_33 = climb_tier;
            uint param_34 = last_tier_index;
            uint param_35 = last_level_index;
            uint _1975 = try_upward_free(param_33, param_34, param_35);
            succ = _1975;
            if (succ == 1u)
            {
                return true;
            }
            else
            {
                uint param_36 = last_modify;
                print_treelet(param_36);
            }
            uint param_37 = climb_tier + 1u;
            uint param_38 = tier_index;
            uint param_39 = level_index;
            uint _1993 = try_part_lock(param_37, param_38, param_39);
            uint next_succ = _1993;
            uint param_40 = last_modify;
            print_treelet(param_40);
            if (next_succ == 2u)
            {
            }
            uint param_41 = climb_tier;
            uint param_42 = last_tier_index;
            uint _2005 = try_resolve(param_41, param_42);
            succ = _2005;
            uint param_43 = last_modify;
            print_treelet(param_43);
            if (succ == 2u)
            {
                return false;
            }
            if (next_succ == 2u)
            {
                break;
            }
            climb_tier++;
            continue;
        }
        else
        {
            break;
        }
    }
    if (succ == 0u)
    {
        uint param_44 = climb_tier;
        uint param_45 = tier_index;
        uint param_46 = level_index;
        uint _2031 = try_part_free(param_44, param_45, param_46);
        succ = _2031;
        uint param_47 = last_modify;
        print_treelet(param_47);
        if (succ == 0u)
        {
            uint param_48 = climb_tier;
            uint param_49 = tier_index;
            uint _2043 = try_resolve(param_48, param_49);
            uint param_50 = last_modify;
            print_treelet(param_50);
        }
    }
    else
    {
        return false;
    }
    return true;
}

bool try_alloc(inout uint level, inout uint index)
{
    fail_level = 0u;
    uint old_level = level;
    uint old_index = index;
    uint param = index;
    uint param_1 = level;
    uint param_2;
    uint param_3;
    uint param_4;
    uint param_5;
    uint param_6;
    bool param_7;
    break_index(param, param_1, param_2, param_3, param_4, param_5, param_6, param_7);
    index = param;
    level = param_1;
    uint tier = param_2;
    uint subtier = param_3;
    uint tier_index = param_4;
    uint level_index = param_5;
    uint lowest_bit = param_6;
    bool is_lowest = param_7;
    uint param_8 = tier;
    uint _2085 = tier_offset(param_8);
    uint true_index = tier_index + _2085;
    uint succ;
    if (is_lowest)
    {
        uint param_9 = 0u;
        uint param_10 = tier_index;
        uint param_11 = (level_index * 2u) + lowest_bit;
        uint _2099 = try_part_alloc(param_9, param_10, param_11);
        succ = _2099;
    }
    else
    {
        fail_level++;
        uint param_12 = true_index;
        uint param_13 = subtier;
        uint param_14 = level_index;
        uint _2109 = try_base_alloc(param_12, param_13, param_14);
        succ = _2109;
        if (succ != 2u)
        {
        }
    }
    if (succ != 2u)
    {
        uint param_15 = last_modify;
        print_treelet(param_15);
    }
    else
    {
        return false;
    }
    uint climb_tier = tier + 1u;
    for (;;)
    {
        uint param_16 = 4u;
        uint _2133 = NO_UNROLL(param_16);
        if (climb_tier < _2133)
        {
            if (succ == 2u)
            {
                break;
            }
            fail_level++;
            uint param_17 = tier_index;
            uint param_18 = level_index;
            level_up_index(param_17, param_18);
            tier_index = param_17;
            level_index = param_18;
            uint param_19 = climb_tier;
            uint param_20 = tier_index;
            uint param_21 = level_index;
            uint _2155 = try_part_alloc(param_19, param_20, param_21);
            succ = _2155;
            if (succ != 2u)
            {
                uint param_22 = last_modify;
                print_treelet(param_22);
            }
            climb_tier++;
            continue;
        }
        else
        {
            break;
        }
    }
    if (succ != 2u)
    {
        fail_level = 0u;
        return true;
    }
    uint param_23 = old_level;
    uint param_24 = old_index;
    uint param_25 = climb_tier;
    bool _2177 = try_free(param_23, param_24, param_25);
    bool good_free = _2177;
    if (!good_free)
    {
    }
    return false;
}

uint alloc(uint level)
{
    uint param = level;
    uint _2228 = next_alloc_idx(param);
    uint index = _2228;
    uint tries = 0u;
    tries = 0u;
    for (;;)
    {
        uint param_1 = 30u;
        uint _2238 = NO_UNROLL(param_1);
        if (tries < _2238)
        {
            if (tries != 0u)
            {
                fail_count++;
            }
            uint param_2 = level;
            uint param_3 = index;
            bool _2250 = try_alloc(param_2, param_3);
            if (_2250)
            {
                break;
            }
            uint param_4 = level;
            uint _2256 = next_alloc_idx(param_4);
            index = _2256;
            tries++;
            continue;
        }
        else
        {
            break;
        }
    }
    if (tries >= 30u)
    {
        return 3735928559u;
    }
    fail_count = 1u;
    last_succ_adr = index;
    uint adr = index * 1u;
    return adr;
}

uint simple_task(uint val)
{
    uint param = 1u;
    uint _2347 = alloc(param);
    uint ptr = _2347;
    data[(ptr * 4 + 4)/4]= val;
    return ptr;
}

void flag(uint bit)
{
    uint _2344;
    InterlockedOr(geom[(8)/4], 1u << bit, _2344);
}

uint snatch_task_chain_at_level(uint level, inout uint chain_index, bool empty_okay)
{
    uint param = task_op_hash;
    uint param_1 = gid + last_good_op_index;
    uint task_op_hash_1 = FNV1_a_hash_combine(param, param_1);
    uint i = 0u;
    for (;;)
    {
        uint param_2 = task[(4)/4];
        uint _2389 = NO_UNROLL(param_2);
        if (i < _2389)
        {
            uint offset = (i + task_op_hash_1) % task[(4)/4];
            uint task_idx = (task[(0)/4] * offset) + level;
            uint task_adr = task[(task_idx * 4 + 12)/4];
            if (task_adr == 3735928559u)
            {
                uint _2438 = i;
                i = _2438 + uint(1);
                continue;
            }
            if ((task_adr == 3237998146u) && (!empty_okay))
            {
                uint _2438 = i;
                i = _2438 + uint(1);
                continue;
            }
            uint _2427;
            InterlockedCompareExchange(task[(task_idx * 4 + 12)/4], task_adr, 3735928559u, _2427);
            uint swap = _2427;
            if (swap != task_adr)
            {
                uint _2438 = i;
                i = _2438 + uint(1);
                continue;
            }
            else
            {
                chain_index = task_idx;
                return task_adr;
            }
            uint _2438 = i;
            i = _2438 + uint(1);
            continue;
        }
        else
        {
            break;
        }
    }
    chain_index = 3735928559u;
    return 3735928559u;
}

bool insert_task_chain(uint task_chain_head, uint chain_index)
{
    uint _2366;
    InterlockedCompareExchange(task[(chain_index * 4 + 12)/4], 3735928559u, task_chain_head, _2366);
    uint swap = _2366;
    return swap == 3735928559u;
}

uint update_ra_val(uint old_ra, int delta_ready, int delta_active)
{
    uint ready = (old_ra & 2147479552u) >> 12u;
    uint act = old_ra & 4095u;
    ready += uint(delta_ready);
    act += uint(delta_active);
    uint new_ra = old_ra & 2147483648u;
    new_ra |= (act & 4095u);
    new_ra |= ((ready << 12u) & 2147479552u);
    return new_ra;
}

void update_ready_active(int delta_ready, int delta_active)
{
    uint old_ra = local_ready_active + 1u;
    uint swap = local_ready_active;
    uint loop_count = 0u;
    uint new_ra;
    while (swap != old_ra)
    {
        old_ra = swap;
        uint param = old_ra;
        int param_1 = delta_ready;
        int param_2 = delta_active;
        new_ra = update_ra_val(param, param_1, param_2);
        uint _2548;
        InterlockedCompareExchange(task[(8)/4], old_ra, new_ra, _2548);
        swap = _2548;
        if (loop_count >= 10u)
        {
            break;
        }
        loop_count++;
    }
    local_ready_active = new_ra;
}

void dump_bucket()
{
    if (gl_LocalInvocationIndex == 0u)
    {
        if (active_link == 3735928559u)
        {
            uint param = 5u;
            uint _2867 = alloc(param);
            active_link = _2867;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    uint full_count = 0u;
    uint rem_count = 31u;
    uint iter = 0u;
    for (; iter < full_count; iter++)
    {
        uint idx = (iter * 64u) + gl_LocalInvocationIndex;
        data[(((active_link + idx) + 1u) * 4 + 4)/4]= task_bucket.data[task_bucket_count - idx];
    }
    if ((gl_LocalInvocationIndex + (iter * 64u)) < rem_count)
    {
        uint idx_1 = (iter * 64u) + gl_LocalInvocationIndex;
        data[(((active_link + idx_1) + 1u) * 4 + 4)/4]= task_bucket.data[task_bucket_count - idx_1];
    }
    GroupMemoryBarrierWithGroupSync();
    if (gl_LocalInvocationIndex == 0u)
    {
        task_bucket_count -= 31u;
        uint param_1 = bucket_level;
        uint chain_index;
        uint param_2 = chain_index;
        bool param_3 = true;
        uint _2933 = snatch_task_chain_at_level(param_1, param_2, param_3);
        chain_index = param_2;
        uint chain = _2933;
        data[(active_link * 4 + 4)/4]= chain;
        uint param_4 = active_link;
        uint param_5 = chain_index;
        bool _2942 = insert_task_chain(param_4, param_5);
        active_link = 3735928559u;
        int delta_ready = 1;
        int delta_active = 0;
        int param_6 = delta_ready;
        int param_7 = delta_active;
        update_ready_active(param_6, param_7);
    }
    GroupMemoryBarrierWithGroupSync();
}

void queue_task(inout uint task_adr)
{
    GroupMemoryBarrierWithGroupSync();
    if (gl_LocalInvocationIndex == 0u)
    {
        tasks_to_process = 0u;
    }
    GroupMemoryBarrierWithGroupSync();
    uint fill_index = 3735928559u;
    if (task_adr != 3735928559u)
    {
        uint _3049;
        InterlockedAdd(tasks_to_process, 1u, _3049);
        fill_index = _3049;
    }
    GroupMemoryBarrierWithGroupSync();
    uint loop_count = 0u;
    for (;;)
    {
        uint _3058 = tasks_to_process + task_bucket_count;
        uint param = 124u;
        uint _3060 = NO_UNROLL(param);
        if (_3058 > _3060)
        {
            uint fill_amount = 124u - task_bucket_count;
            GroupMemoryBarrierWithGroupSync();
            if (fill_index < 124u)
            {
                task_bucket.data[fill_index] = task_adr;
                task_adr = 3735928559u;
                uint _3072;
                InterlockedAdd(task_bucket_count, 1u, _3072);
                uint _3074;
                InterlockedAdd(tasks_to_process, 4294967295u, _3074);
            }
            else
            {
                if (task_adr != 3735928559u)
                {
                    fill_index -= fill_amount;
                }
            }
            GroupMemoryBarrierWithGroupSync();
            dump_bucket();
            GroupMemoryBarrierWithGroupSync();
            if (loop_count < 10u)
            {
                loop_count++;
            }
            else
            {
                break;
            }
            continue;
        }
        else
        {
            break;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    if (fill_index != 3735928559u)
    {
        task_bucket.data[fill_index] = task_adr;
        uint _3099;
        InterlockedAdd(task_bucket_count, 1u, _3099);
        uint _3100;
        InterlockedAdd(tasks_to_process, 4294967295u, _3100);
    }
    GroupMemoryBarrierWithGroupSync();
}

void do_simple_task()
{
    GroupMemoryBarrierWithGroupSync();
    uint task_ptr = current_task.data[gl_LocalInvocationIndex];
    uint task_to_queue_1 = 3735928559u;
    uint task_to_queue_2 = 3735928559u;
    if (task_ptr != 3735928559u)
    {
        uint val = data[(task_ptr * 4 + 4)/4];
        val++;
        if (val < 0u)
        {
            uint param = val;
            uint _3123 = simple_task(param);
            task_to_queue_1 = _3123;
            uint param_1 = val;
            uint _3126 = simple_task(param_1);
            task_to_queue_2 = _3126;
        }
        else
        {
            uint param_2 = 20u;
            flag(param_2);
        }
    }
    uint param_3 = task_to_queue_1;
    queue_task(param_3);
    uint param_4 = task_to_queue_2;
    queue_task(param_4);
    GroupMemoryBarrierWithGroupSync();
}

bool free(uint level, uint adr)
{
    uint index = adr / 1u;
    uint param = level;
    uint param_1 = index;
    uint param_2 = 3u;
    bool _2279 = try_free(param, param_1, param_2);
    return _2279;
}

void refresh_ready_active()
{
    uint _2561;
    InterlockedCompareExchange(task[(8)/4], local_ready_active, local_ready_active, _2561);
    local_ready_active = _2561;
}

uint2 snatch_task_chain(inout uint chain_index, bool empty_okay)
{
    uint param = task_op_hash;
    uint param_1 = gid + last_good_op_index;
    uint task_op_hash_1 = FNV1_a_hash_combine(param, param_1);
    uint i = 0u;
    for (;;)
    {
        uint param_2 = task[(0)/4];
        uint _2460 = NO_UNROLL(param_2);
        if (i < _2460)
        {
            uint level = (task[(0)/4] - i) - 1u;
            uint param_3 = level;
            uint param_4 = chain_index;
            bool param_5 = empty_okay;
            uint _2475 = snatch_task_chain_at_level(param_3, param_4, param_5);
            chain_index = param_4;
            uint adr = _2475;
            if (adr != 3735928559u)
            {
                return uint2(adr, level);
            }
            i++;
            continue;
        }
        else
        {
            break;
        }
    }
    chain_index = 3735928559u;
    return uint2(3735928559u, 0u);
}

void load_link(out bool did_init)
{
    if (passes >= 1u)
    {
    }
    passes++;
    did_init = false;
    if (local_ready_active == 2147483648u)
    {
        uint _2575;
        InterlockedCompareExchange(task[(8)/4], 2147483648u, 1u, _2575);
        uint swap = _2575;
        if (swap == 2147483648u)
        {
            uint param = 31u;
            flag(param);
            log_idx++;
            did_init = true;
            bucket_level = 0u;
            task_bucket_count = 0u;
            if (geom.Load(draw[(0)/4] * 4 + 4) == 3735928559u)
            {
                uint param_1 = 3u;
                uint _2601 = alloc(param_1);
                uint adr = _2601;
                geom[(draw[(0)/4] * 4 + 4)/4]= adr;
                for (uint i = 0u; i < 8u; i++)
                {
                    data[((adr + i) * 4 + 4)/4]= 3735928559u;
                }
            }
            uint param_2 = 0u;
            uint _2626 = simple_task(param_2);
            task_bucket.data[0] = _2626;
            local_ready_active = 1u;
        }
        else
        {
            local_ready_active = swap;
        }
        should_wait = true;
        return;
    }
    refresh_ready_active();
    if (local_ready_active == 0u)
    {
        should_exit = true;
        return;
    }
    bool valid_snatch = false;
    uint loop_count = 0u;
    while ((local_ready_active & 2147479552u) != 0u)
    {
        uint param_3 = 5u;
        flag(param_3);
        if (loop_count < 10u)
        {
            loop_count++;
        }
        else
        {
            break;
        }
        uint chain_index = 3735928559u;
        if (task_bucket_count == 0u)
        {
            last_bucket_level = bucket_level;
            uint param_4 = chain_index;
            bool param_5 = false;
            uint2 _2673 = snatch_task_chain(param_4, param_5);
            chain_index = param_4;
            uint2 the_chain = _2673;
            if (the_chain.x == 3735928559u)
            {
                continue;
            }
            bucket_level = the_chain.y + 0u;
            if (last_bucket_level != bucket_level)
            {
                should_wait = true;
            }
            active_link = the_chain.x;
        }
        else
        {
            uint param_6 = bucket_level;
            uint param_7 = chain_index;
            bool param_8 = false;
            uint _2699 = snatch_task_chain_at_level(param_6, param_7, param_8);
            chain_index = param_7;
            uint the_chain_1 = _2699;
            if (the_chain_1 == 3735928559u)
            {
                continue;
            }
            active_link = the_chain_1;
        }
        uint next_link = data[(active_link * 4 + 4)/4];
        uint param_9 = next_link;
        uint param_10 = chain_index;
        bool _2715 = insert_task_chain(param_9, param_10);
        valid_snatch = true;
    }
    if (!valid_snatch)
    {
        uint param_11 = 4u;
        flag(param_11);
        should_wait = true;
    }
}

void dumb_fill_bucket()
{
    if (active_link != 3735928559u)
    {
        uint param = 5u;
        uint param_1 = active_link;
        bool _2729 = free(param, param_1);
        active_link = 3735928559u;
    }
    bool did_init = false;
    bool param_2 = did_init;
    load_link(param_2);
    did_init = param_2;
    int delta_ready = (active_link != 3735928559u) ? (-1) : 0;
    bool _2742 = task_bucket_count > 0u;
    bool _2748;
    if (!_2742)
    {
        _2748 = active_link != 3735928559u;
    }
    else
    {
        _2748 = _2742;
    }
    bool has_tasks = _2748 || did_init;
    int delta_active;
    if ((!currently_active) && has_tasks)
    {
        uint param_3 = 12u;
        flag(param_3);
        currently_active = true;
        delta_active = 1;
        has_worked = true;
    }
    else
    {
        if (currently_active && (!has_tasks))
        {
            uint param_4 = 13u;
            flag(param_4);
            currently_active = false;
            delta_active = -1;
        }
        else
        {
            if (currently_active && has_tasks)
            {
                uint param_5 = 14u;
                flag(param_5);
                delta_active = 0;
            }
            else
            {
                if ((!currently_active) && (!has_tasks))
                {
                    uint param_6 = 15u;
                    flag(param_6);
                    delta_active = 0;
                }
            }
        }
    }
    bool _2791 = !did_init;
    bool _2799;
    if (_2791)
    {
        _2799 = (delta_ready != 0) || (delta_active != 0);
    }
    else
    {
        _2799 = _2791;
    }
    if (_2799)
    {
        int param_7 = delta_ready;
        int param_8 = delta_active;
        update_ready_active(param_7, param_8);
        if (local_ready_active == 0u)
        {
            uint param_9 = 16u;
            flag(param_9);
            should_exit = true;
            return;
        }
    }
    if (should_exit)
    {
        uint param_10 = 8u;
        flag(param_10);
    }
    if (should_wait)
    {
        uint param_11 = 9u;
        flag(param_11);
    }
    bool _2830;
    if (!should_wait)
    {
        _2830 = should_exit;
    }
    else
    {
        _2830 = should_wait;
    }
    if (_2830)
    {
        return;
    }
    uint param_12 = 10u;
    flag(param_12);
    for (uint idx = 0u; idx < 31u; idx++)
    {
        task_bucket.data[task_bucket_count] = data.Load(((active_link + idx) + 1u) * 4 + 4);
        task_bucket_count++;
    }
}

void dumb_claim_task()
{
    GroupMemoryBarrierWithGroupSync();
    if (gl_LocalInvocationIndex == 0u)
    {
        tasks_to_process = 0u;
        should_wait = false;
        uint index = 0u;
        for (uint idx = 0u; idx < 64u; idx++)
        {
            if (current_task.data[gl_LocalInvocationIndex] == 3735928559u)
            {
                tasks_to_process++;
            }
        }
        uint param = tasks_to_process;
        uint unroll_val = NO_UNROLL(param);
        bool not_done = unroll_val > 0u;
        uint loop_count = 0u;
        while (not_done)
        {
            while (current_task.data[index] != 3735928559u)
            {
                index++;
            }
            if (task_bucket_count == 0u)
            {
                dumb_fill_bucket();
            }
            bool _3012;
            if (!should_wait)
            {
                _3012 = should_exit;
            }
            else
            {
                _3012 = should_wait;
            }
            if (_3012)
            {
                tasks_to_process = 0u;
            }
            else
            {
                if (task_bucket_count > 0u)
                {
                    task_bucket_count--;
                    current_task.data[index] = task_bucket.data[task_bucket_count];
                    task_bucket.data[task_bucket_count] = 3735928559u;
                }
            }
            if (loop_count < 10u)
            {
                loop_count++;
            }
            else
            {
                tasks_to_process = 0u;
            }
            uint param_1 = tasks_to_process;
            not_done = NO_UNROLL(param_1) > 0u;
        }
    }
    GroupMemoryBarrierWithGroupSync();
}

void galloc_finalize()
{
    uint adr = bucket;
    uint index = adr / 1u;
    if (bucket != 3735928559u)
    {
        uint param = 1u;
        uint param_1 = index;
        uint param_2 = 3u;
        bool _2336 = try_free(param, param_1, param_2);
    }
}

void comp_main()
{
    _log_overflow = false;
    _current_chunk = 3735928559u;
    _log_pos = 32u;
    uint_to_exact_table = 2340u;
    actually_alloced = false;
    bucket = 3735928559u;
    last = 0u;
    last_succ_adr = 0u;
    fail_count = 1u;
    na_hash = 0u;
    task_op_hash = 0u;
    last_good_op_index = 0u;
    local_ready_active = 2147483648u;
    has_worked = false;
    log_idx = 0u;
    if (gl_LocalInvocationIndex == 0u)
    {
        should_exit = false;
        should_wait = false;
        active_link = 3735928559u;
        bucket_level = 3735928559u;
        last_bucket_level = 3735928559u;
        task_bucket_count = 0u;
        currently_active = false;
        passes = 0u;
        for (uint i = 0u; i < 124u; i++)
        {
            task_bucket.data[i] = 3735928559u;
        }
        INIT_NO_UNROLL();
    }
    current_task.data[gl_LocalInvocationIndex] = 3735928559u;
    GroupMemoryBarrierWithGroupSync();
    galloc_initialize();
    GroupMemoryBarrierWithGroupSync();
    uint loop_count = 0u;
    while (!should_exit)
    {
        do_simple_task();
        uint param = 1u;
        if (loop_count >= NO_UNROLL(param))
        {
            if (gl_LocalInvocationIndex == 0u)
            {
                if (has_worked)
                {
                    uint param_1 = 0u;
                    flag(param_1);
                }
                else
                {
                    if (local_ready_active == 1u)
                    {
                        uint param_2 = 1u;
                        flag(param_2);
                    }
                    else
                    {
                        if (local_ready_active == 0u)
                        {
                            uint param_3 = 2u;
                            flag(param_3);
                        }
                        else
                        {
                            if (local_ready_active == 2147483648u)
                            {
                                uint param_4 = 21u;
                                flag(param_4);
                            }
                            else
                            {
                                uint param_5 = 3u;
                                flag(param_5);
                            }
                        }
                    }
                }
            }
            break;
        }
        loop_count++;
        current_task.data[gl_LocalInvocationIndex] = 3735928559u;
        dumb_claim_task();
        GroupMemoryBarrierWithGroupSync();
    }
    if (!should_exit)
    {
        uint param_6 = 24u;
        flag(param_6);
    }
    if (active_link != 3735928559u)
    {
        uint param_7 = 5u;
        uint param_8 = active_link;
        bool _3225 = free(param_7, param_8);
        active_link = 3735928559u;
    }
    galloc_finalize();
}

[numthreads(8, 8, 1)]
void main(SPIRV_Cross_Input stage_input)
{
    gl_GlobalInvocationID = stage_input.gl_GlobalInvocationID;
    gl_LocalInvocationIndex = stage_input.gl_LocalInvocationIndex;
    comp_main();
}
