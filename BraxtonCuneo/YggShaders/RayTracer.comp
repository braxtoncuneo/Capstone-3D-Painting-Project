//These should be set by the interchange to dimensions appropriate to the GPU
#define X_SIZE 64

#define MEMORY_SWAP_FREQ 8
#define TASK_SWAP_FREQ	4

#define DEPTH_LIMIT 8

layout(std430, binding = 5) buffer TraceLayoutBuffer { uvec2 data[]; };
restrict writeonly image2D outputImage;

uniform mat4 viewMatrix;
uniform uint pixWidth;
uniform uint pixHeight;
uniform uint depthLimit;
uniform vec3 horizonColor;
uint pixNo;
uint traceTask;
uint trace;


// This should be replaced with the contents of CommonCode.comp
#include "CommonCode.comp"


/// Trace Management

/* Fills the Trace Layout Buffer with a series of coordinates which tile the
** grid space of the output image along a row-major, column-minor sequence.
** If the output image is not a perfect square with a power-of-two side length,
** the gridspace is decomposed into squares with a power-of-two side length
** and individually tiled.
*/
void spoolScanlineLayout(){

    for(uint pos = id; pos < pixNo; pos += THREAD_COUNT){
        TraceLayoutBuffer.data[pos] = uvec2(pos%THREAD_COUNT,pos/THREAD_COUNT);
    }

}


/* Fills the Trace Layout Buffer with a series of coordinates which tile the
** grid space of the output image along a hilbert curve. If the output image is
** not a perfect square with a power-of-two side length, the gridspace is
** decomposed into squares with a power-of-two side length and individually
** tiled.
*/
/// THIS FUNCTION IS NOT FINISHED
void spoolHilbertTraceLayout(){

    uvec2 botLeft;
    uvec2 topRight;
    uvec2 coord;
    uint trMin;
    bool done;

    /// Decomposing the screen space into squares
    for(uint pos = id; pos < pixNo; pos += THREAD_COUNT){
		done = false;
		botLeft = uvec2(0,0);
		topRight = uvec2(pixWidth,pixHeight);
		coord = uvec2(pos%THREAD_COUNT,pos/THREAD_COUNT);
		while(!done){
			trMin = int(log2(float(min(topRight)));
			botLeft +=	trMin *
						uvec2(greaterThan((coord - botLeft),uvec2(trMin,trMin));
		}
    }

}



/* Fills out a traceNode with the data for the initial state of the root state
** indicated by the input traceTask Node.
*/
traceNode traceTaskToTrace(in traceTaskNode task){

	traceNode result;
	result.last = NOT_THERE;
	result.next = NOT_THERE;
    result.host = BlockBuffer[0].root;
    result.stackHead = NOT_THERE;
    result.stackCount = 0;
    result.overlapHead = NOT_THERE;
    result.state = 0;
    result.distanceLeft = traceCheck(task.position,task.velocity);
    result.position = task.position;
    result.velocity = task.velocity;

}


/*
** Returns the time required to enter the voxel. If the trace is
** already in the voxel, returns 0.0. If the trace will not ever enter the
** block, given the position and velocity, the returned value is negative.
** This is used at the beginning of trace lines through specific blocks.
*/
float traceCheck( in vec3 position, in vec3 velocity ){
	float result;
	/*
	** Find what time differences are required to hit each of the positive
	** and negative sides of the unit cube
	*/
	vec3 negativeSide = (vec3(-1.0,-1.0,-1.0) - position) / velocity;
	vec3 positiveSide =  (vec3(1.0,1.0,1.0) - position) / velocity;

	/*
	** Whichever side (positive or negative) with the lower intersect time must,
	** by definition, be the side entered through by the trace. Here, we sort
	** times such that the enter and exit times for each dimension are separated
	** into the enter and exit vectors;
	*/
	vec3 enter = min(negativeSide,positiveSide);
	vec3 exit = max(negativeSide,positiveSide);

	/*
	** In order to be inside the box, the trace must have hit all of the 'enter'
	** points before any of the 'exit' points. The range vector establishes the
	** true entrance and exit times for the trace.
	*/
	vec2 range = vec2(	max(enter.x,max(enter.y,enter.z)),
						min(exit.x,min(exit.y,exit.z)));
	// If the trace is already in the unit cube, the returned value is 0.0
	if(lessThanEqual(range.x,range.y) && lessThanEqual(0.0,range.y)){
        result = max(0.0,range.x);
	}
	else{
		// If no intersection is possible, a negative value is returned
		result = -1.0;
	}
	return result;
}

/*
** Returns the index of the next child node area to be intersected by the trace.
** If the trace is to exit the voxel before intersecting with another child
** node, it returns eight. Additionally, the variable time returns the time
** to the next child voxel, if applicable.
*/
uint childHit( 	out float time, in uint currentChild,
				in vec3 position, in vec3 velocity){
	// Result starts off as the childless result
	uint result = 8;
	// Calculates each dimensional intercept of the trace in the unit cube
	vec3 crossPoint = (vec3(0.0,0.0,0.0) - position) / velocity;
	/*
	** Result for a dimension is true only if a cross across its intercept
	** occurs before or simultaneous to all other intercepts and time left is
	** greater than 0.0
	*/
	bvec3 crossStats =	greaterThan(vec3(crossPoint,0.0,0.0,0.0)) &&
						greaterThanEqual(crossPoint,crossPoint.yzx) &&
						greaterThanEqual(crossPoint,crossPoint.zxy);

	/*
	** If there is any valid crossing, the child being crossed into is the one
	** with the bits corresponding to the minimal valid crossing(s)
	*/
	if(any(crossStats)){
		time = min(crossPoint.x,min(crossPoint.y,crossPoint.z));
		uint crossBits = 	uint(crossStats.x) +
							(uint(crossStats.y) << 1)+
							(uint(crossStats.z) << 2);
		result = currentChild ^ crossBits;
	}
	return result;
}

/*
** Returns whether or not the surface is hit. If so, time is changed to match
** the time to the surface hit.
*/
bool surfaceHit(	out float time, in uint posMask, in uvec3 intPos,
					in vec3 position, in vec3 velocity, in vec4 surface){
	bool result = false;
	if(length(surface.xyz)!=0){
		float velDir = dot(surface.xyz,velocity);
		float posDir = dot(surface.xyz,position);
	}
	return result;
}



/*
** This function is in charge of freeing all of the resources associated with
** a trace branch an all of its child traces. While somewhat of a bottleneck
** to the ray tracer, it is the cost of having good transparency and being able
** to escape the computation required of multiple, unsynced traces.
*/
void cleanUpTraceBranch( in uint traceBranchRoot, in traceNode data ){

	/*
	** This stack stores mapped nodes which have "next" nodes that have yet
	** to be processed.
	*/
	uint mapStackHead = NOT_THERE;
	uint mapStackCount = 0;

	// Remove the root node from the rest of the trace tree
	uint rootNext;
	uint rootLast;
	if( data.Next != NOT_THERE ){
		traceLast(data.Next) = data.Last;
	}
	if( data.Last != NOT_THERE ){
		traceNext(data.Last) = data.Next;
	}
	freeNode(traceBranchRoot);

	/*
	** Push the first overlapping node of the root onto the stack. If there are
	** no overlapping nodes, the job of cleaning up is done.
	*/
	uint iter = data.overlapHead;
	if(iter != NOT_THERE){
		pushStackUint(mapStackHead,mapStackCount,iter);
	}
	uint next;
	uint overlap;

	// While there are nodes on the stack, there are nodes to free
	while(mapStackCount != 0){

		// Store the 'next' and 'overlap' fields of the top node, for future use
		next = traceNext(iter);
		overlap = traceOverlapHead(iter);

		/*
		** If the current trace has a non-null overlap field, place the first
		** overlap on the top of the stack then set the overlap field of the
		** original node to the next overlapping trace.
		*/
		if( overlap != NOT_THERE ){
			traceOverlapHead(iter) = traceNext(overlap);
			pushStackUint(mapStackHead,mapStackCount,overlap);
			iter = overlap;
		}
		/*
		** If the current trace has no overlapping traces but has a 'next'
		** trace, the top of the stack is set to the next trace and the
		** original trace is freed.
		*/
		else if( next != NOT_THERE ){
			// Unwind the trace's stack before it is freed
			destroyStackUint(traceStackHead(iter),traceStackCount(iter));
			freeNode(iter);
			stackTopUint(mapStackHead,mapStackCount) = next;
			iter = next;
		}
		/*
		** If the current trace has neither overlapping traces nor 'next'
		** traces, the trace is freed and the top of the mapping stack is popped
		*/
		else{
			// Unwind the trace's stack before it is freed
			destroyStackUint(traceStackHead(iter),traceStackCount(iter));
			freeNode(iter);
			popStackUint(deleteHead,deleteCount);
			iter = stackTopUint(mapStackHead,mapStackCount);
		}

	}

}




void onHit(	in uvec4 incident, in uvec4 abcident,
			in vec3 velocity, in vec3 normal){

	/// Inject the "On Hit" code here. *Super Important*
	/*
	** We might be able to expose this stuff to the user later
	** For now, this will either include the basic or full forward tracer code.
	*/

}

void onMarch(	inout vec4 mask, inout vec4 sample,
				in float timeMarched, in uvec4 material){

	/// Inject the "On March" code here. *Super Important*
	/*
	** We might be able to expose this stuff to the user later
	** For now, this will either include the basic or full forward tracer code.
	*/

}

/*
** marchTrace is the powerhouse of the ray tracer. With each execution, it
** takes the current trace branch and marches the root forward by the amount of
** time left until the next hit occurs (somewhere in the trace tree). Along the
** way, the next best hit time is also calculated so that, once the hit has
**
*/
uint marchTrace(inout uint trace,
				inout vec2 bestTimes, inout uvec2 bestTraces,
				inout vec3 colorMask, inout vec3 lightSample,
				inout bool traceTreeHit, inout traceTreeDone){


	traceNode data = loadTrace(trace);

	// Advance trace by the current best time
    data.position.xyz = data.position.xyz + data.velocity.xyz * bestTimes.x;
	data.timeLeft = data.TimeLeft - bestTimes.x;
	onMarch(colorMask,lightSample,bestTimes.x,data.attributes);
	if(data.TimeLeft < HIT_DISTANCE){
		onHit( data.attributes,data.velocity,d);
	}

    if(trace == bestTraces.x){
        data.timeLeft = distToHit();
        if(data.timeLeft < bestTimes.y){
            bestTimes.y = data.timeLeft;
            bestTraces.y = trace;
            if(data.timeLeft < bestSteps.x){
                bestTimes.xy = vec2(data.timeLeft,bestTimes.x);
                bestTraces.xy = uvec2(trace,bestTraces.x);
            }
        }
    }
    else{

    }

	/* If the traversal stack of the trace is empty, it is done and should be
	** cleaned up. Otherwise, the data for the trace is stored back into the
	** the trace tree.
	*/
	if(data.stackCount == 0){
		cleanUpTraceBranch;
	}
	else{
		storeTrace(trace,data);
	}

	// Set the trace tree iterator to the next appropriate node.
	trace = trace.Next
}


uint hitTrace(	inout uint trace,
				inout vec2 bestTimes, inout uvec2 bestTraces,
				inout vec3 colorMask, inout vec3 lightSample,
				inout bool traceTreeHit, inout traceTreeDone){



}


/// Task Management Code

layout(local_size_x = X_SIZE) in;
void main(){

	vec2 bestSteps;
	uvec2 bestTraces;
	vec3 colorMask = vec3(1.0,1.0,1.0);
	vec3 lightSample = vec3(0.0,0.0,0.0);
	uint traceRoot;
	traceNode traceData;
	traceTaskNode taskData;
	pixNo = pixHeight * pixWidth;
	uint root_task;
	bool traceTreeHit;
	bool traceTreeDone = false;

	// Initialize the Thread State and Root Task
	initYggCompute();
	if(id == 0){
		TaskBuffer.data[ROOT_TASK] = grabTask(); // Establish the root task
		traceTaskParent(ROOT_TASK) = NOT_THERE;
		traceTaskChildCount(ROOT_TASK) = 0;
	}
	root_task = TaskBuffer[ROOT_TASK];
	memoryBarrierBuffer();

	// Spool Trace Layout

	/*
	** This is not included for testing. While important for cache optimization,
	** it complicates matters of debugging.
	*/



	traceTask = NOT_THERE;
	trace = NOT_THERE;
	// Perform traces until the root task is out of children
	while( traceTaskChildCount(root_task) != 0 ){

		// Grab a new task from the task queue, if needed and possible
		if(traceTreeDone){
			cleanUpTraceBranch(trace);
			trace = NOT_THERE;
		}
		if(trace == NOT_THERE){
			traceTask = grabTask();
			if(traceTask != NOT_THERE){
				taskData = traceTaskLoad(traceTask);
				traceData = traceTaskToTrace(taskData);
				traceRoot = allocNode();
				traceStore(traceRoot,traceData);
				traceTreeState = 0;
			}
		}

		// Only check for new tasks after every TASK_SWAP_FREQ hit calculations
		for(uint swapStep = 0; swapStep < TASK_SWAP_FREQ; swapStep++){
			trace = traceRoot;
			// Only process hits after every HIT_PROC_FREQ march traversals
			for(uint hitStep = 0; hitStep < HIT_PROC_FREQ; swapStep++){

				while( (trace != NOT_THERE) && !done ){
					marchTrace(trace,bestSteps,bestTraces,colorMask,lightSample);
				}
			}

		}

	}

}





