// These should be set by the interchange to dimensions appropriate to the GPU
#define X_SIZE				64

// These should be set as
#define MEMORY_SWAP_FREQ	8
#define TASK_SWAP_FREQ		4
#define HIT_PROC_FREQ		4

#define DEPTH_LIMIT			8

#define HIT_DISTANCE		( 1.0 / float( 1 << 22 ) )

#define STATE_TYPE_MASK		0xF0000000
	#define STATE_ENTER			0x10000000
	#define STATE_CHILD			0x20000000
	#define STATE_SURFACE		0x30000000
	#define STATE_EXIT			0x40000000
#define STATE_TARGET_MASK	0x000000F0
	#define STATE_TGT_X			0x00000010
	#define STATE_TGT_Y			0x00000020
	#define STATE_TGT_Z			0x00000040
	#define STATE_TGT_OUT		0x00000080
#define	STATE_LOCALE_MASK	0x0000000F
	#define STATE_LOC_X			0x00000001
	#define STATE_LOC_Y			0x00000002
	#define STATE_LOC_Z			0x00000004
	#define STATE_LOC_OUT		0x00000008
#define STATE_MAT_STORED	0x00000100


layout(std430, binding = 5) buffer TraceLayoutBuffer { uvec2 data[]; };
restrict writeonly image2D outputImage;

uniform mat4 viewMatrix;
uniform uint pixWidth;
uniform uint pixHeight;
uniform uint depthLimit;
uniform uvec4 horizonMat;
uniform float alphaThresh;
uint pixNo;
uint traceTask;
uint trace;


// This should be replaced with the contents of CommonCode.comp
#include "CommonCode.comp"


/// Trace Management

/* Fills the Trace Layout Buffer with a series of coordinates which tile the
** grid space of the output image along a row-major, column-minor sequence.
** If the output image is not a perfect square with a power-of-two side length,
** the gridspace is decomposed into squares with a power-of-two side length
** and individually tiled.
*/
void spoolScanlineLayout(){

    for(uint pos = id; pos < pixNo; pos += THREAD_COUNT){
        TraceLayoutBuffer.data[pos] = uvec2(pos%THREAD_COUNT,pos/THREAD_COUNT);
    }

}


/* Fills the Trace Layout Buffer with a series of coordinates which tile the
** grid space of the output image along a hilbert curve. If the output image is
** not a perfect square with a power-of-two side length, the gridspace is
** decomposed into squares with a power-of-two side length and individually
** tiled.
*/
/// THIS FUNCTION IS NOT FINISHED
void spoolHilbertTraceLayout(){

    uvec2 botLeft;
    uvec2 topRight;
    uvec2 coord;
    uint trMin;
    bool done;

    /// Decomposing the screen space into squares
    for(uint pos = id; pos < pixNo; pos += THREAD_COUNT){
		done = false;
		botLeft = uvec2(0,0);
		topRight = uvec2(pixWidth,pixHeight);
		coord = uvec2(pos%THREAD_COUNT,pos/THREAD_COUNT);
		while(!done){
			trMin = int(log2(float(min(topRight)));
			botLeft +=	trMin *
						uvec2(greaterThan((coord - botLeft),uvec2(trMin,trMin));
		}
    }

}



/* Fills out a traceNode with the data for the initial state of the root state
** indicated by the input traceTask Node.
*/
traceNode traceTaskToTrace(in traceTaskNode task){

	traceNode result;
	result.last = NOT_THERE;
	result.next = NOT_THERE;
    result.host = BlockBuffer[0].root;
    result.stackHead = NOT_THERE;
    result.stackCount = 0;
    result.overlapHead = NOT_THERE;
    result.state = 0;
    result.distanceLeft = traceCheck(task.position,task.velocity);
    result.position = task.position;
    result.velocity = task.velocity;

}


/*
** Returns the time required to enter the voxel. If the trace is
** already in the voxel, returns 0.0. If the trace will not ever enter the
** block, given the position and velocity, the returned value is negative.
** This is used at the beginning of trace lines through specific blocks.
*/
float traceCheck( in vec3 position, in vec3 velocity ){
	float result;
	/*
	** Find what time differences are required to hit each of the positive
	** and negative sides of the unit cube
	*/
	vec3 negativeSide = (vec3(-1.0,-1.0,-1.0) - position) / velocity;
	vec3 positiveSide =  (vec3(1.0,1.0,1.0) - position) / velocity;

	/*
	** Whichever side (positive or negative) with the lower intersect time must,
	** by definition, be the side entered through by the trace. Here, we sort
	** times such that the enter and exit times for each dimension are separated
	** into the enter and exit vectors;
	*/
	vec3 enter = min(negativeSide,positiveSide);
	vec3 exit = max(negativeSide,positiveSide);

	/*
	** In order to be inside the box, the trace must have hit all of the 'enter'
	** points before any of the 'exit' points. The range vector establishes the
	** true entrance and exit times for the trace.
	*/
	vec2 range = vec2(	max(enter.x,max(enter.y,enter.z)),
						min(exit.x,min(exit.y,exit.z)));
	// If the trace is already in the unit cube, the returned value is 0.0
	if(lessThanEqual(range.x,range.y) && lessThanEqual(0.0,range.y)){
        result = max(0.0,range.x);
	}
	else{
		// If no intersection is possible, a negative value is returned
		result = -1.0;
	}
	return result;
}

/*
** Returns the index of the next child node area to be intersected by the trace.
** If the trace is to exit the voxel before intersecting with another child
** node, it returns eight. Additionally, the variable time returns the time
** to the next child voxel, if applicable.
*/
uint childHit( 	out float time, in uint currentChild,
				in vec3 position, in vec3 velocity){
	// Result starts off as the childless result
	uint result = 8;
	// Calculates each dimensional intercept of the trace in the unit cube
	vec3 crossPoint = (vec3(0.0,0.0,0.0) - position) / velocity;
	/*
	** Result for a dimension is true only if a cross across its intercept
	** occurs before or simultaneous to all other intercepts and time left is
	** greater than 0.0
	*/
	bvec3 crossStats =	greaterThan(vec3(crossPoint,0.0,0.0,0.0)) &&
						greaterThanEqual(crossPoint,crossPoint.yzx) &&
						greaterThanEqual(crossPoint,crossPoint.zxy);

	/*
	** If there is any valid crossing, the child being crossed into is the one
	** with the bits corresponding to the minimal valid crossing(s)
	*/
	if(any(crossStats)){
		time = min(crossPoint.x,min(crossPoint.y,crossPoint.z));
		uint crossBits = 	uint(crossStats.x) +
							(uint(crossStats.y) << 1)+
							(uint(crossStats.z) << 2);
		result = currentChild ^ crossBits;
	}
	return result;
}



// Returns the normal of eligible non-surface hit boundaries
vec3 getChildHitNormal(in vec3 position){
	vec3 centerVec = vec3(0.5,0.5,0.5);
	vec3 boundVec = vec3(1.0,1.0,1.0);
	vec3 hitVec	= vec3(HIT_DISTANCE,HIT_DISTANCE,HIT_DISTANCE);
	vec3 hitPos = mod(position,boundVec)-centerVec;
	return normalize(sign(hitPos)*vec3(lessThanEqual(abs(hitPos),hitVec)));
}


/*
** Returns whether or not the surface is hit. If so, time is changed to match
** the time to the surface hit.
*/
bool surfaceHit(	out float time, in uint posMask, in uvec3 intPos,
					in vec3 position, in vec3 velocity, in vec4 surface){
	bool result = false;
	if(length(surface.xyz)!=0){
		float velDir = dot(surface.xyz,velocity);
		float posDir = dot(surface.xyz,position);
	}
	return result;
}



/*
** This function is in charge of freeing all of the resources associated with
** a trace branch an all of its child traces. While somewhat of a bottleneck
** to the ray tracer, it is the cost of having good transparency and being able
** to escape the computation required of multiple, unsynced traces.
*/
void cleanUpTraceBranch( in uint traceBranchRoot, in traceNode data ){

	/*
	** This stack stores mapped nodes which have "next" nodes that have yet
	** to be processed.
	*/
	uint mapStackHead = NOT_THERE;
	uint mapStackCount = 0;

	// Remove the root node from the rest of the trace tree
	if( data.Next != NOT_THERE ){
		traceLast(data.Next) = data.Last;
	}
	if( data.Last != NOT_THERE ){
		// If the trace is not the next of its last, it is the overlap
		if(traceNext(data.Last) != traceBranchRoot){
			traceOverlapHead(data.Last) = data.Next;
		}
		else{
			traceNext(data.Last) = data.Next;
		}
	}
	freeNode(traceBranchRoot);

	/*
	** Push the first overlapping node of the root onto the stack. If there are
	** no overlapping nodes, the job of cleaning up is done.
	*/
	uint iter = data.overlapHead;
	if(iter != NOT_THERE){
		pushStackUint(mapStackHead,mapStackCount,iter);
	}
	uint next;
	uint overlap;

	// While there are nodes on the stack, there are nodes to free
	while(mapStackCount != 0){

		// Store the 'next' and 'overlap' fields of the top node, for future use
		next = traceNext(iter);
		overlap = traceOverlapHead(iter);

		/*
		** If the current trace has a non-null overlap field, place the first
		** overlap on the top of the stack then set the overlap field of the
		** original node to the next overlapping trace.
		*/
		if( overlap != NOT_THERE ){
			traceOverlapHead(iter) = traceNext(overlap);
			pushStackUint(mapStackHead,mapStackCount,overlap);
			iter = overlap;
		}
		/*
		** If the current trace has no overlapping traces but has a 'next'
		** trace, the top of the stack is set to the next trace and the
		** original trace is freed.
		*/
		else if( next != NOT_THERE ){
			// Unwind the trace's stack before it is freed
			destroyStackUvec3(traceStateStackHead(iter),traceStateStackCount(iter));
			destroyStackUint(traceMatStackHead(iter),traceMatStackCount(iter));
			freeNode(iter);
			stackTopUint(mapStackHead,mapStackCount) = next;
			iter = next;
		}
		/*
		** If the current trace has neither overlapping traces nor 'next'
		** traces, the trace is freed and the top of the mapping stack is popped
		*/
		else{
			// Unwind the trace's stack before it is freed
			destroyStackUvec3(traceStateStackHead(iter),traceStateStackCount(iter));
			destroyStackUint(traceMatStackHead(iter),traceMatStackCount(iter));
			freeNode(iter);
			popStackUint(deleteHead,deleteCount);
			iter = stackTopUint(mapStackHead,mapStackCount);
		}

	}

}




void onHit(	in uvec4 incident, in uvec4 abcident,
			in vec3 velocity, in vec3 normal){

	/// Inject the "On Hit" code here. *Super Important*
	/*
	** We might be able to expose this stuff to the user later
	** For now, this will either include the basic or full forward tracer code.
	*/

}

void onMarch(	inout vec4 mask, inout vec4 sample,
				in float timeMarched, in uvec4 material){

	/// Inject the "On March" code here. *Super Important*
	/*
	** We might be able to expose this stuff to the user later
	** For now, this will either include the basic or full forward tracer code.
	*/

}

/*
** marchTrace is the powerhouse of the ray tracer. With each execution, it
** takes the current trace branch and marches the root forward by the amount of
** time left until the next hit occurs (somewhere in the trace tree).
**
*/
uint marchTrace(inout uint trace,
				inout float currentStep, inout float soonestNextHit,
				inout vec3 colorMask, inout vec3 lightSample,
				inout uint hitStackTop, inout uint hitStackCount,
				inout uint cleanStackTop, inout uint cleanStackCount){


	// Load in our trace data from the data buffer.
	traceNode data = loadTrace(trace);

	/*
	** Advance trace by the currentStep, update the trace's hit countdown,
	** and perform onMarch calculations
	*/
    data.position.xyz = data.position.xyz + data.velocity.xyz * bestTimes.x;
	data.timeLeft = data.TimeLeft - currentStep;
	onMarch(colorMask,lightSample,currentStep,data.attributes);

	/*
	** If the amount of time left is within the hit threshold, it is added to
	** the hit stack for later processing. Otherwise, the timeLeft value
	** represents a hit in a future pass, and hence must be incorporated into
	** the soonestNextHit calculation.
	*/
	if(data.TimeLeft < HIT_DISTANCE){
		pushStackUint(hitStackTop,hitStackCount,trace);
	}
	else{
		soonestNextHit = min(soonestNextHit,data.timeLeft);
	}

	// Store trace data for future use.
	storeTrace(trace,data);

	// Set the trace tree iterator to the next appropriate node.
	if(trace.overlapHead != NOT_THERE){
		trace = trace.overlapHead;
	}
	else{
		trace = trace.Next;
	}

}


/*
** Iterates down the cleaning stack, cleaning up each trace in the structure.
** Should one of the traces be the root of this thread's current trace tree,
** we set the variable holding this root trace to NOT_THERE, indicating the
** current trace tree is finished.
*/
void cleanSweep(inout uint cleanStackTop, inout uint cleanStackCount,
				inout uint rootTrace){

	uint current;
    while(cleanStackCount > 0){
		current = stackTopUint(cleanStackTop,cleanStackCount);
		cleanUpTraceBranch(current);
		popStackUint(cleanStackTop,cleanStackCount);
		if(current == rootTrace){
			rootTrace = NOT_THERE;
		}
    }

}

// Stores the index current host node of the trace at the top of its mat stack
void storeOldVoxel(inout traceNode data, in uint host){
	if(data.state & STATE_MAT_STORED == 0){
		data.state |= STATE_MAT_STORED;
		pushStackTop(data.matStackTop,data.matStackCount,host);
	}
}

/*
** Finds the topmost trace index with a corresponding hit type equal to testVal
** and places the index into currentTrace and the data into data. Additionally,
** all processed trace indexes, regardless of qualifying, are placed into the
** filter stack. If no valid trace is found, NOT_THERE is returned.
*/
void filter(	inout uint hitStackTop, inout uint hitStackCount,
				inout uint filterStackTop, inout uint filterStackCount,
				inout uint currentTrace, inout traceNode data, in uint testVal){
	uint hitType;
	// Place non-exiting hits into the filter stack
	while(hitStackCount > 0){
		currentTrace = stackTopUint(hitStackTop,hitStackCount);
		popStackUint(hitStackTop,hitStackCount);
		// Load trace data and get the type of hit
		data = traceLoad(currentTrace);
		hitType = data.state & STATE_TYPE_MASK;
		pushStackUint(filterStackTop,filterStackCount,currentTrace);
		if(hitType != testVal){
			continue;
		}
		else{
			break;
		}
	}
	if(hitStackCount == 0){
		currentTrace = NOT_THERE;
	}
}

// Returns the state of a trace after an enter hit event
void enterState(inout traceNode data){

	storeOldVoxel(data,NOT_THERE);
	uint state = data.state;
	uint loc = (data.state & STATE_TARGET_MASK) >> 4;
	state = state & (~(STATE_LOCALE_MASK | STATE_TARGET_MASK));
	state = state | loc;
	uint tgt = childHit(data.timeleft, loc, data.position, data.velocity);
	state = state | (tgt << 4);

}

// Returns the state of a trace after an exit hit event
void exitState(inout traceNode data){

	// Get the state of the trace one level up
	uvec3 stateTop = readTopUvec3(data.stateStackTop,data.stateStackCount);
	uint locale = data.state & STATE_LOCALE_MASK;

	popStackUvec3(data.stateStackTop,data.stateStackCount);

	// If the current host voxel is the top of the mat stack, remove it
	if(stackTopUint(data.matStackTop,data.matStackCount)==data.host){
		popStackUint(data.matStackTop,data.matStackCount);
	}
	// Update host-specific data
	data.host = stateTop.x;
	data.state = stateTop.y;
	data.velocity /= 2.0;
	data.position = data.position / 2.0 - (0.5).xxx +
					vec3(greaterThan(	locale.xxx^uvec3(1,2,4),
										(0).xxx					));
	data.timeLeft = uintBitsToFloat(stateTop.z);

}

// Returns the state of a trace after a child hit event
void childState(inout traceNode data){



}

// Returns the state of a trace after a surface hit event
void surfaceState(inout traceNode data){



}


void enterSweep(	inout uint hitStackTop, inout uint hitStackCount,
					inout uint cleanStackTop, inout uint cleanStackCount){
	uint currentTrace;
	traceNode data;
	uint filterStackTop = NOT_THERE;
	uint filterStackCount = 0;
	// Keep processing hits until there are no more
	while(hitStackCount > 0){
		// Get the topmost entering trace
		filter(	hitStackTop,hitStackCount,filterStackTop,filterStackCount,
				currentTrace, data, STATE_ENTER);
		//Sets up the trace for a potential child hit after entrance
		if( currentTrace != NOT_THERE ){
			// If the current host voxel is the top of the mat stack, remove it
			enterState(data);
		}
    }
    // Place the filtered hits back into the hit stack for future processes
    hitStackTop = filterStackTop;
    hitStackCount = filterStackCount;
}


void exitSweep(	inout uint hitStackTop, inout uint hitStackCount,
				inout uint cleanStackTop, inout uint cleanStackCount){
	uint hitType;
	uint hitTarget;
	uvec3 stateTop;
	vec3 normal;
	uint currentTrace;
	traceNode data;
	// Keep processing hits until there are no more
	while(hitStackCount > 0){
		// Get the topmost entering trace
		filter(	hitStackTop,hitStackCount,filterStackTop,filterStackCount,
				currentTrace, data, STATE_EXIT);
		/*
		** While the hit currently being processed is an exit from the current
		** voxel space, exit out to the parent voxel space. If the root voxel
		** has been exited out of, then that means the trace is done and hence
		** should be cleaned up.
		*/
		if(currentTrace != NOT_THERE){
			hitType = data.state & STATE_TYPE_MASK;
			while( (hitType == STATE_EXIT) && (data.timeLeft < HIT_DISTANCE) ){
				if(data.stateStackCount == 0){
					pushStackUint(cleanStackTop,cleanStackCount,currentTrace);
					break;
				}
				else{
					exitState(data);
					hitType = data.state & STATE_TYPE_MASK;
				}
			}
		}
		traceStore(currentTrace,data);
    }
    // Place the filtered hits back into the hit stack for future processes
    hitStackTop = filterStackTop;
    hitStackCount = filterStackCount;
}


void childSweep(	inout uint hitStackTop, inout uint hitStackCount,
					inout uint cleanStackTop, inout uint cleanStackCount){
	uint hitType;
	uint hitTarget;
	uvec3 stateTop;
	vec3 normal;
	uint currentTrace;
	traceNode data;
	// Keep processing hits until there are no more
	while(hitStackCount > 0){
		// Get the topmost entering trace
		filter(	hitStackTop,hitStackCount,filterStackTop,filterStackCount,
				currentTrace, data, STATE_CHILD);
		/*
		** While the hit currently being processed is traveling between
		** the boundaries between child voxels or into child voxels, update
		** the trace's data appropriately. If the depth limit has been hit,
		** halt further traversal.
		*/
		if(currentTrace != NOT_THERE){
			hitType = data.state & STATE_TYPE_MASK;
			while( (hitType == STATE_CHILD) && (data.timeLeft < HIT_DISTANCE) ){
				if(data.stateStackCount == 0){
					pushStackUint(cleanStackTop,cleanStackCount,currentTrace);
					break;
				}
				else{
					childState(data);
					hitType = data.state & STATE_TYPE_MASK;
				}
			}
		}
		traceStore(currentTrace,data);
	}
	// Place the filtered hits back into the hit stack for future processes
	hitStackTop = filterStackTop;
	hitStackCount = filterStackCount;
}


void surfaceSweep(	inout uint hitStackTop, inout uint hitStackCount,
					inout uint cleanStackTop, inout uint cleanStackCount){
	uint currentTrace;
	traceNode data;
	uint filterStackTop = NOT_THERE;
	uint filterStackCount = 0;
	// Keep processing hits until there are no more
	while(hitStackCount > 0){
		// Get the topmost entering trace
		filter(	hitStackTop,hitStackCount,filterStackTop,filterStackCount,
				currentTrace, data, STATE_SURFACE);
		//Sets up the trace for a potential child hit after entrance
		if( currentTrace != NOT_THERE ){
			surfaceState(data);
		}
    }
    // Place the filtered hits back into the hit stack for future processes
    hitStackTop = filterStackTop;
    hitStackCount = filterStackCount;
}


void hitSweep(	inout uint hitStackTop, inout uint hitStackCount){
	uint oldVoxel;
	uint newVoxel;
	uvec4 oldMat;
	uvec4 newMat;
	uint hitType;
	uint hitTarget;
	uvec3 stateTop;
	vec3 normal;
	uint currentTrace;
	traceNode data;
	// Keep processing hits until there are no more
	while(hitStackCount > 0){
		// Get the hit currently being processed and remove it from the stack
		currentTrace = stackTopUint(hitStackTop,hitStackCount);
		popStackUint(hitStackTop,hitStackCount);
		data = traceLoad(currentTrace);

		// Get the indexes of the voxels enc
		oldVoxel = stackTopUint(trace.matStackTop,trace.matStackCount);
		popStackUint(trace.matStackTop,trace.matStackCount);
		newVoxel = stackTopUint(trace.matStackTop,trace.matStackCount);

		if(oldVoxel == NOT_THERE){
			oldMat = horizonMat;
		}
		else{
			oldMat = vec4(	voxelAttribute(oldVoxel,0),
							voxelAttribute(oldVoxel,1),
							voxelAttribute(oldVoxel,2),
							voxelAttribute(oldVoxel,3)	);
		}

		if(newVoxel == NOT_THERE){
			newMat = horizonMat;
		}
		else{
			newMat = vec4(	voxelAttribute(newVoxel,0),
							voxelAttribute(newVoxel,1),
							voxelAttribute(newVoxel,2),
							voxelAttribute(newVoxel,3)	);
		}

		hitType = data.state & STATE_TYPE_MASK;
		data.state = data.state & ( ~ STATE_MAT_STORED );

		// Get the normal of the hit surface
		if( hitType == HIT_SURFACE ){
            normal = (unpackSnorm4x8(traceSurface(data.host))).xyz;
		}
		else{
			normal = getChildHitNormal(data.position);
		}

		// Pass the appropriate data to the onHitFunction
		onHit( oldMat, newMat, data.velocity, normal );
		traceStore(currentTrace,data);
    }

}


/// Task Management Code

layout(local_size_x = X_SIZE) in;
void main(){

	float currentStep;
	float soonestNextHit;
	vec3 colorMask = vec3(1.0,1.0,1.0);
	vec3 lightSample = vec3(0.0,0.0,0.0);
	uint traceRoot;
	traceNode traceData;
	traceTaskNode taskData;
	pixNo = pixHeight * pixWidth;
	uint root_task;
	bool traceTreeHit;
	bool traceTreeDone = false;

	uint hitStackTop = NOT_THERE;
	uint hitStackCount = 0;
	uint cleanStackTop = NOT_THERE;
	uint cleanStackCount = 0;

	// Initialize the Thread State and Root Task
	initYggCompute();
	if(id == 0){
		TaskBuffer.data[ROOT_TASK] = grabTask(); // Establish the root task
		traceTaskParent(ROOT_TASK) = NOT_THERE;
		traceTaskChildCount(ROOT_TASK) = 0;
	}
	root_task = TaskBuffer[ROOT_TASK];
	memoryBarrierBuffer();

	// Spool Trace Layout
	spoolScanlineLayout();


	traceTask = NOT_THERE;
	trace = NOT_THERE;
	// Perform traces until the root task is out of children
	while( traceTaskChildCount(root_task) != 0 ){

		// If this thread just finished up a trace, clean it up
		if(traceTreeDone){
			cleanUpTraceBranch(trace);
			trace = NOT_THERE;
		}
		// Grab a new task from the task queue, if needed and possible
		if(trace == NOT_THERE){
			traceTask = grabTask();
			// Only set up trace if the grabbed task address is valid
			if(traceTask != NOT_THERE){
				taskData = traceTaskLoad(traceTask);
				traceData = traceTaskToTrace(taskData);
				traceRoot = allocNode();
				traceStore(traceRoot,traceData);
				traceTreeState = 0;
			}
		}

		// Only check for new tasks after every TASK_SWAP_FREQ hit calculations
		for(uint swapStep = 0; swapStep < TASK_SWAP_FREQ; swapStep++){
			trace = traceRoot;
			while( trace != NOT_THERE ){
				// Execute march operations down the trace tree
				marchTrace(trace,bestSteps,bestTraces,colorMask,lightSample);
			}
			// Process pending hit operations
			enterSweep(hitStackTop,hitStackCount,cleanStackTop,cleanStackCount);
			exitSweep(hitStackTop,hitStackCount,cleanStackTop,cleanStackCount);
			childSweep(hitStackTop,hitStackCount,cleanStackTop,cleanStackCount);
			surfaceSweep(hitStackTop,hitStackCount,cleanStackTop,cleanStackCount);
			hitSweep(hitStackTop,hitStackCount);
			/*
			** If the color mask has hit the alpha threshold, the entire trace
			** tree is cleaned up.
			*/
			if(max(colorMask) < alphaThresh){
				destroyStackUint(cleanStackTop,cleanStackCount);
				pushStackUint(cleanStackTop,cleanStackCount,traceRoot)
			}
			// Process pending cleanup operations
			cleanSweep(cleanStackTop,cleanStackCount,traceRoot);

		}

	}

}





