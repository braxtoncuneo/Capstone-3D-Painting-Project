#define NODE_SIZE	16
#define HEADER_SIZE	4
#define ATT_NUM		4
#define CHILD_NUM	8
#define NOT_THERE	0x3FFFFFFF
#define CACHED		0x40000000
#define COPY_WRITE	0x80000000

#define NODE_PLAIN_COLOR	0x00000000
#define NODE_TEXTURE_MAP	0x00000001

#define HEAPSIZE 4

layout(std430, binding = 0) buffer DataBuffer { uint data[]; };

layout(std430, binding = 1) buffer HeadBuffer { uint data[]; };

layout(std430, binding = 2) buffer HeapBuffer { uint data[]; };

layout(std430, binding = 3) buffer TaskBuffer { uint data[]; };

layout(std430, binding = 4) buffer ExchangeBuffer { uint data[]; };

layout(std430, binding = 5) uniform TransformBuffer { mat4 data[]; };

uint heapCounts_loc[2];
uint heaps_loc[2];
uint taskQCounts_loc[2];
uint taskQs_loc[2];
uint id;

uint metaIdx( in uint node ){
	return node*NODE_SIZE;
}

uint surfIdx( in uint node ){
	return node*NODE_SIZE + 1;
}

uint lightListIdx( in uint node ){
	return node*NODE_SIZE + 2;
}

uint overlapListIdx( in uint node ){
	return node*NODE_SIZE + 3;
}

uint attributeIdx( in uint node, in uint idx ){
	return node*NODE_SIZE + HEADER_SIZE + idx;
}

uint childIdx( in uint node, in uint idx ){
	return node*NODE_SIZE + HEADER_SIZE + ATT_NUM + idx;
}

uint rsrcLeftIdx(){
	return id*HEAPSIZE;
}

uint rsrcRightIdx(){
	return id*HEAPSIZE + 1;
}

uint rsrcLeftCountIdx(){
	return id*HEAPSIZE + 2;
}

uint rsrcRightCountIdx(){
	return id*HEAPSIZE + 3;
}

uint allocNode(){
	uint bigger = uint(lessThan(heapCounts_loc[0],heapCounts_loc[1]);
	uint result = heaps_loc[bigger];
	heaps_loc[bigger] = DataBuffer.data[childIdx(result,0)];
	heapCounts_loc[bigger]--;
}

void freeNode( in uint node ){
	uint smaller = uint(greaterThan(heapCounts_loc[0],heapCounts_loc[1]);
	DataBuffer.data[childIdx(node,0)] = heaps_loc[smaller];
	heaps_loc[smaller] = node;
	heapCounts_loc[smaller]++;
}

void pushHeaps(){
	HeapBuffer.data[rsrcLeftIdx()] = heaps_loc[0];
	HeapBuffer.data[rsrcRightIdx()] = heaps_loc[1];
	HeapBuffer.data[rsrcLeftCountIdx()] = heapCounts_loc[0];
	HeapBuffer.data[rsrcRightCountIdx()] = heapCounts_loc[1];
}

void pullHeaps(){
	heaps_loc[0] = HeapBuffer.data[rsrcLeftIdx()];
	heaps_loc[1] = HeapBuffer.data[rsrcRightIdx()];
	heapCounts_loc[0] = HeapBuffer.data[rsrcLeftCountIdx()];
	heapCounts_loc[1] = HeapBuffer.data[rsrcRightCountIdx()];
}

uint grabTask(){
	uint bigger = uint(lessThan(taskQCounts_loc[0],taskQCounts_loc[1]);
	uint result = taskQs_loc[bigger];
	taskQs_loc[bigger] = DataBuffer.data[childIdx(result,0)];
	taskQCounts_loc[bigger]--;
}

void postTask( in uint node ){
	uint smaller = uint(greaterThan(taskQCounts_loc[0],taskQCounts_loc[1]);
	DataBuffer.data[childIdx(node,0)] = taskQs_loc[smaller];
	taskQs_loc[smaller] = node;
	taskQCounts_loc[smaller]++;
}

void pushTaskQs(){
	HeapBuffer.data[rsrcLeftIdx()] = taskQs_loc[0];
	HeapBuffer.data[rsrcRightIdx()] = taskQs_loc[1];
	HeapBuffer.data[rsrcLeftCountIdx()] = taskQCounts_loc[0];
	HeapBuffer.data[rsrcRightCountIdx()] = taskQCounts_loc[1];
}

void pullTaskQs(){
	taskQs_loc[0] = TaskBuffer.data[rsrcLeftIdx()];
	taskQs_loc[1] = TaskBuffer.data[rsrcRightIdx()];
	taskQCounts_loc[0] = TaskBuffer.data[rsrcLeftCountIdx()];
	taskQCounts_loc[1] = TaskBuffer.data[rsrcRightCountIdx()];
}


void levelHeaps( in uint len ){
	uint bigger = uint(lessThan(heapCounts_loc[0],heapCounts_loc[1]);
	uint smaller = 1-bigger;
	uint diff = abs(heapCounts_loc[0]-heapCounts_loc[1]);
	uint iter = heaps_loc[bigger];
	for(uint i = 0; i < len; i++){
		if(i < diff - 1){
			iter = DataBuffer.data[childIdx(iter,0)];
		}
	}
	if(diff > 0){
		heaps_loc[bigger] = DataBuffer.data[childIdx(iter,0)];
		DataBuffer.data[childIdx(iter,0)] = heaps_loc[smaller];
		heapCounts[smaller] += diff;
		heapCounts[bigger] += diff;
	}
}

void levelTasks( in uint len ){
	uint bigger = uint(lessThan(taskQCounts_loc[0],taskQCounts_loc[1]);
	uint smaller = 1-bigger;
	uint diff = abs(taskQCounts_loc[0]-taskQCounts_loc[1]);
	uint iter = taskQs_loc[bigger];
	for(uint i = 0; i < len; i++){
		if(i < diff - 1){
			iter = DataBuffer.data[childIdx(iter,0)];
		}
	}
	if(diff > 0){
		taskQs_loc[bigger] = DataBuffer.data[childIdx(iter,0)];
		DataBuffer.data[childIdx(iter,0)] = taskQs_loc[smaller];
		taskQCounts[smaller] += diff;
		taskQCounts[bigger] += diff;
	}
}

void pushStackUint(inout uint top, inout uint count, in uint val){
	uint modPt = count % (NODE_SIZE - 1);
	uint result = top;
    if( modPt == 0 ){
		result = allocNode();
		DataBuffer[NODE_SIZE*result] = top;
		top = result;
    }
    DataBuffer[NODE_SIZE*top + 1 + modPt] = val;
    count++;
}

void popStackUint(inout uint top, inout uint count){
	uint modPt = count % (NODE_SIZE - 1);
	uint result = top;
    if( modPt == 1 ){
		result = DataBuffer[NODE_SIZE*top];
		freeNode(top);
		top = result;
    }
    count--;
}

uint peekStackUint(in uint top, in uint count){
	uint modPt = count % (NODE_SIZE - 1);
	return DataBuffer[NODE_SIZE*top + 1 + modPt];
}

uint childSeek(	in uint currentNode, in uint posMask,
				in uvec3 current, in uvec3 target	){
	uint idx = 0;

    if( ( target.x & posMask ) > ( current.x & posMask ) ){
		idx |= 1;
    }
    if( ( target.y & posMask ) > ( current.y & posMask ) ){
		idx |= 2;
    }
    if( ( target.z & posMask ) > ( current.z & posMask ) ){
		idx |= 4;
    }
    return DataBuffer[childIdx(currentNode,idx)];
}

vec4 getLocalCoordinates(in vec4 currentCoords, in mat4 childTransform){
	return childTransform * currentCoords;
}

vec4 getVoxelCoordinates(in )

bool hitsSurface( 	in vec4 position, in vec4 direction,
					in float scale, in uint surf ){
	vec4 surface = unpackSNorm(surf);
	vec4 start = mod(position+scale/2,scale)/scale;
	vec4 end = start + direction * scale;
	start = dot(start.xyz,surface.xyz);
	end = dot(end.xyz,surface.xyz);
    bool hits = any( lessThanEqual(
					vec2(	dot(start.xyz,surface.xyz),
							dot(end.xyz,surface.xyz)	),
					surface.ww
				));
	sta

}

uint makePlainColorNode(in vec4 color, in vec4 surf){
	uint result = allocNode();
    DataBuffer[metaIdx(result)] = NODE_PLAIN_COLOR;
    DataBuffer[surfIdx(result)] = packSNorm4x8(surf);
    DataBuffer[lightListIdx(result)] = 0;
    DataBuffer[overlapListIdx(result)] = 0;
    DataBuffer[attributeIdx(result,0)] = packSNorm4x8(color);
    for(uint i = 0; i < 8; i++){
		DataBuffer[attributeIdx(result,i)] = NOT_THERE;
    }
}


void initYggCompute(){
	id = gl_GlobalInvocationID();
	pullHeaps();
	pullTaskQs();
}



