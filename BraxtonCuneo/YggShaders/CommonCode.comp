#define NODE_SIZE		16
#define HEADER_SIZE		4
#define ATT_NUM			4
#define CHILD_NUM		8
#define THREAD_COUNT	4096
#define RSRC_PER		3
#define RSRC_SIZE		2
#define RSRC_IDX_OFFSET THREAD_COUNT * RSRC_PER * RSRC_SIZE
#define HIT_DISTANCE 	1.0 / 256.0


#define NOT_THERE	0x7FFFFFFF
#define CACHED		0x80000000

#define NODE_PLAIN_COLOR	0x00000000
#define NODE_TEXTURE_MAP	0x00000001



/// Yggdrasil Buffer Definitions

layout(std430, binding = 0) buffer DataBuffer { uint data[]; };

layout(std430, binding = 1) buffer BlockBuffer { uint data[]; };

layout(std430, binding = 2) buffer HeapBuffer { uint data[]; };

layout(std430, binding = 3) buffer TaskBuffer { uint data[]; };

layout(std430, binding = 4) buffer ExchangeBuffer { uint data[]; };




/// Global values and struct defs for managing common resources

struct voxelNode{
    uint meta;
    uint surface;
    uint light;
    uint overlap;
    uvec4 attributes;
    uint child[8];
};

struct traceNode{
    uint nextNode;
    uint lastNode;
    uint hostNode;
    uint stackHead;
    uint stackCount;
    uint overlapHead;
    uint distanceLeft;
    uvec3 intPosition;
    vec3 position;
    vec3 velocity;
};

uint heapIdxs_loc[2];
uint heapCounts_loc[2];
uint heapHeads_loc[2];

uint taskQIdxs_loc[2];
uint taskQCounts_loc[2];
uint taskQHeads_loc[2];

uint id;
uint swapBit = 1;


/// Direct Node Member Access Macros

#define voxelMeta(node)				DataBuffer.data[ node * NODE_SIZE]
#define voxelSurface(node)			DataBuffer.data[ node * NODE_SIZE + 1 ]
#define voxelLight(node)			DataBuffer.data[ node * NODE_SIZE + 2 ]
#define voxelOverlap(node)			DataBuffer.data[ node * NODE_SIZE + 3 ]
#define voxelAttribute(node,idx)	DataBuffer.data[ node * NODE_SIZE + 4 + idx ]
#define voxelChild(node,idx)		DataBuffer.data[ node * NODE_SIZE + 8 + idx ]

#define traceLast(node)					DataBuffer.data[ node * NODE_SIZE ]
#define traceNext(node)					DataBuffer.data[ node * NODE_SIZE + 1 ]
#define traceHostNode(node)				DataBuffer.data[ node * NODE_SIZE + 2 ]
#define traceStackHead(node)			DataBuffer.data[ node * NODE_SIZE + 3 ]
#define traceStackCount(node)			DataBuffer.data[ node * NODE_SIZE + 4 ]
#define traceOverlapHead(node)			DataBuffer.data[ node * NODE_SIZE + 5 ]
#define traceDistanceLeft(node)			DataBuffer.data[ node * NODE_SIZE + 6 ]
#define traceIntegerPosition(node,idx)	DataBuffer.data[ node * NODE_SIZE + 7  + idx ]
#define tracePosition(node,idx)			DataBuffer.data[ node * NODE_SIZE + 10 + idx ]
#define traceVelocity(node,idx)			DataBuffer.data[ node * NODE_SIZE + 13 + idx ]


/// Node Loading/Storing

traceNode traceLoad(in uint node){
	traceNode result;
    result.lastNode =		traceLast(node);
	result.nextNode =		traceLast(node);
    result.hostNode =		traceHostNode(node);
    result.stackHead =		traceStackHead(node);
    result.stackCount =		traceStackCount(node);
    result.overlapHead = 	traceOverlapHead(node);
    result.distanceLeft =	uintBitsToFloat(traceDistanceLeft(node));
    result.intPosition = 	uvec3(	traceIntegerPosition(node,0),
									traceIntegerPosition(node,1),
									traceIntegerPosition(node,2) );
    result.position = 	vec3(	uintBitsToFloat(tracePosition(node,0)),
								uintBitsToFloat(tracePosition(node,1)),
								uintBitsToFloat(tracePosition(node,2)) );
    result.velocity = 	vec3(	uintBitsToFloat(traceVelocity(node,0)),
								uintBitsToFloat(traceVelocity(node,1)),
								uintBitsToFloat(traceVelocity(node,2)) );
    return result;
}


void traceStore(in uint node, in traceNode trace){
    traceLast(node) =				trace.lastNode;
	traceNext(node) =				trace.nextNode;
    traceHostNode(node) =			trace.hostNode;
    traceStackHead(node) =			trace.stackHead;
    traceStackCount(node) =			trace.stackCount;
    traceOverlapHead(node) =		trace.overlapHead;
    traceDistanceLeft(node) =		floatBitsToUint(trace.distanceLeft);
    traceIntegerPosition(node,0) =	trace.intPosition.x;
    traceIntegerPosition(node,1) =	trace.intPosition.y;
    traceIntegerPosition(node,2) =	trace.intPosition.z;
    tracePosition(node,0) =			floatBitsToUint(trace.position.x);
    tracePosition(node,1) =			floatBitsToUint(trace.position.y);
    tracePosition(node,2) =			floatBitsToUint(trace.position.z);
    traceVelocity(node,0) =			floatBitsToUint(trace.velocity.x);
    traceVelocity(node,1) =			floatBitsToUint(trace.velocity.y);
    traceVelocity(node,2) =			floatBitsToUint(trace.velocity.z);
}


/// Resource Value Indexing Functions

uint heapHeadIdx(in uint idx){
	return heapIdxs_loc[idx]*RSRC_SIZE;
}

uint heapCountIdx(in uint idx){
	return heapIdxs_loc[idx]*RSRC_SIZE + 1;
}

uint heapIdxIdx(int uint idx){
	return RSRC_IDX_OFFSET + idx;
}

uint taskQHeadIdx(in uint idx){
	return taskQIdxs_loc[idx]*RSRC_SIZE;
}

uint taskQCountIdx(in uint idx){
	return taskQIdxs_loc[idx]*RSRC_SIZE + 1;
}

uint taskQIdxIdx(int uint idx){
	return RSRC_IDX_OFFSET + idx;
}




/// Memory Management Functions

uint allocNode(){
	uint bigger = uint(lessThan(heapCounts_loc[0],heapCounts_loc[1]);
	uint result = heapHeads_loc[bigger];
	heapHeads_loc[bigger] = voxelChild(result,0);
	heapCounts_loc[bigger]--;
}

void freeNode( in uint node ){
	uint smaller = uint(greaterThan(heapCounts_loc[0],heapCounts_loc[1]);
	voxelChild(node,0) = heapHeads_loc[smaller];
	heapHeads_loc[smaller] = node;
	heapCounts_loc[smaller]++;
}

void levelHeaps( in uint len ){
	uint bigger = uint(lessThan(heapCounts_loc[0],heapCounts_loc[1]);
	uint smaller = 1-bigger;
	uint diff = abs(heapCounts_loc[0]-heapCounts_loc[1]);
	uint iter = heapHeads_loc[bigger];
	uint holder;
	for(uint i = 0; i < len; i++){
		if(i < diff - 1){
			iter = voxelChild(iter,0);
		}
	}
	if(diff > 0){
		holder = heapHeads_loc[bigger];
		heapHeads_loc[bigger] = voxelChild(iter,0);
		voxelChild(iter,0) = heapHeads_loc[smaller];
        heapHeads_loc[smaller] = holder;
		heapCounts_loc[smaller] += diff;
		heapCounts_loc[bigger] += diff;
	}
}

void pushHeap(in uint idx){
	HeapBuffer.data[heapHeadIdx(idx)] = heapHeads_loc[idx];
	HeapBuffer.data[heapCountIdx(idx)] = heapCounts_loc[idx];
}

void pullHeap(in uint idx){
	heapHeads_loc[idx] = HeapBuffer.data[heapHeadIdx(idx)];
	heapCounts_loc[idx] = HeapBuffer.data[heapCountIdx(idx)];
}

void rotateHeaps(){
	pushHeap(0);
	uint swpIdx = id ^ swapBit;
    heapHeads_loc[0] = atomicExchange(
						HeapBuffer.data[heapIdxIdx(swpIdx)],
						heapIdxs_loc[0]
					);
	heapHeads_loc[0] = atomicExchange(
						HeapBuffer.data[heapIdxIdx[id]],
						heapIdxs_loc[0]
					);
	uint temp = heapIdxs_loc[0];
	heapIdxs_loc[0] = heapIdxs_loc[1];
	heapIdxs_loc[1] = temp;
	id = (id<<1);
	id = (id >= THREAD_COUNT) ? 1 : id;
    pullHeap(0);
}




/// Task Management Functions

uint grabTask(){
	uint bigger = uint(lessThan(taskQCounts_loc[0],taskQCounts_loc[1]);
	uint result = taskQHeads_loc[bigger];
	taskQHeads_loc[bigger] = voxelChild(result,0);
	taskQCounts_loc[bigger]--;
}

void postTask( in uint node ){
	uint smaller = uint(greaterThan(taskQCounts_loc[0],taskQCounts_loc[1]);
	voxelChild(node,0) = taskQHeads_loc[smaller];
	taskQHeads_loc[smaller] = node;
	taskQCounts_loc[smaller]++;
}

void levelHeaps( in uint len ){
	uint bigger = uint(lessThan(taskQCounts_loc[0],taskQCounts_loc[1]);
	uint smaller = 1-bigger;
	uint diff = abs(taskQCounts_loc[0]-taskQCounts_loc[1]);
	uint iter = taskQHeads_loc[bigger];
	uint holder;
	for(uint i = 0; i < len; i++){
		if(i < diff - 1){
			iter = voxelChild(iter,0);
		}
	}
	if(diff > 0){
		holder = taskQHeads_loc[bigger];
		taskQHeads_loc[bigger] = voxelChild(iter,0);
		voxelChild(iter,0) = taskQHeads_loc[smaller];
        taskQHeads_loc[smaller] = holder;
		taskQCounts_loc[smaller] += diff;
		taskQCounts_loc[bigger] += diff;
	}
}


void pushTaskQ(in uint idx){
	TaskBuffer.data[taskQHeadIdx(idx)] = taskQHeads_loc[idx];
	TaskBuffer.data[taskQCountIdx(idx)] = taskQCounts_loc[idx];
}

void pullTaskQ(in uint idx){
	taskQHeads_loc[idx] = TaskBuffer.data[taskQHeadIdx(idx)];
	taskQCounts_loc[idx] = TaskBuffer.data[taskQCountIdx(idx)];
}

void rotateTaskQs(){
	pushTaskQ(0);
	uint swpIdx = id ^ swapBit;
    taskQHeads_loc[0] = atomicExchange(
						TaskBuffer.data[taskQIdxIdx(swpIdx)],
						taskQIdxs_loc[0]
					);
	taskQHeads_loc[0] = atomicExchange(
						TaskQBuffer.data[taskQIdxIdx[id]],
						taskQIdxs_loc[0]
					);
	uint temp = taskQIdxs_loc[0];
	taskQIdxs_loc[0] = taskQIdxs_loc[1];
	taskQIdxs_loc[1] = temp;
	id = (id<<1);
	id = (id >= THREAD_COUNT) ? 1 : id;
    pullTaskQ(0);
}




/// Unsigned Int Stack

void pushStackUint(inout uint top, inout uint count, in uint val){
	uint modPt = count % (NODE_SIZE - 1);
	uint result = top;
    if( modPt == 0 ){
		result = allocNode();
		DataBuffer[NODE_SIZE*result] = top;
		top = result;
    }
    DataBuffer[NODE_SIZE*top + 1 + modPt] = val;
    count++;
}

void popStackUint(inout uint top, inout uint count){
	uint modPt = count % (NODE_SIZE - 1);
	uint result = top;
    if( modPt == 1 ){
		result = DataBuffer[NODE_SIZE*top];
		freeNode(top);
		top = result;
    }
    count--;
}

uint peekStackUint(in uint top, in uint count){
	uint modPt = count % (NODE_SIZE - 1);
	return DataBuffer[NODE_SIZE*top + 1 + modPt];
}





/// Trace Management Code

float distToHit(	in uint posMask, in uvec3 intPos,
					in vec4 position, in vec4 velocity, in vec4 surface){
	if(length(surface.xyz)!=0){
		float velDir = dot(surface.xyz,velocity.xyz);
		float posDir = dot(surface.xyz,position.xyz);
	}
}

uint marchRay( 	in uint trace, inout vec2 bestSteps, inout uvec2 bestTraces,
				inout vec3 colorMask, inout vec3 lightSample){

	traceNode data = loadTrace(trace);

    data.position.xyz = data.position.xyz + data.velocity.xyz * bestSteps.x;
	data.distanceLeft = data.distanceLeft - bestSteps.x;
	if(data.distanceLeft < HIT_DISTANCE)

    if(trace == bestTraces.x){
        data.distanceLeft = distToHit();
        if(data.distanceLeft > bestSteps.y){
            bestSteps.y = data.distanceLeft;
            bestTraces.y = trace;
            if(data.distanceLeft > bestSteps.x){
                bestSteps.xy = vec2(data.distanceLeft,bestSteps.x);
                bestTraces.xy = uvec2(trace,bestTraces.x);
            }
        }
    }

	storeTrace(trace,data);
    return data.nextNode;
}



/// Other Stuff

uint childSeek(	in uint currentNode, in uint posMask,
				in uvec3 current, in uvec3 target	){
	uint idx = 0;

    if( ( target.x & posMask ) > ( current.x & posMask ) ){
		idx |= 1;
    }
    if( ( target.y & posMask ) > ( current.y & posMask ) ){
		idx |= 2;
    }
    if( ( target.z & posMask ) > ( current.z & posMask ) ){
		idx |= 4;
    }
    return DataBuffer[childIdx(currentNode,idx)];
}

vec4 getLocalCoordinates(in vec4 currentCoords, in mat4 childTransform){
	return childTransform * currentCoords;
}




void initYggCompute(){
	id = gl_GlobalInvocationID();
	pullHeap(0);
	pullHeap(1);
	pullTaskQ(0);
	pullTaskQ(1);
	swapMask = 1;
}



