#define NODE_SIZE		16
#define HEADER_SIZE		4
#define ATT_NUM			4
#define CHILD_NUM		8
#define THREAD_COUNT	4096
#define RSRC_PER		3
#define RSRC_SIZE		2
#define RSRC_IDX_OFFSET THREAD_COUNT * RSRC_PER * RSRC_SIZE
#define ROOT_TASK		RSRC_IDX_OFFSET + THREAD_COUNT * RSRC_PER
#define HIT_DISTANCE 	1.0 / 256.0


#define NOT_THERE	0x7FFFFFFF
#define CACHED		0x80000000

#define NODE_PLAIN_COLOR	0x00000000
#define NODE_TEXTURE_MAP	0x00000001




/// Global values and struct defs for managing common resources

struct voxelNode{
    uint meta;
    uint surface;
    uint light;
    uint overlap;
    uvec4 attributes;
    uint child[8];
};

struct traceNode{
    //0-6
    uint last;
    uint next;
    uint host;
    uint stackHead;
    uint stackCount;
    uint overlapHead;
    float nextHit;
    vec3 position;
    vec3 velocity;
};

struct traceTaskNode{
	uint last;
	uint next;
    uint parent;
    uint childCount;
    vec3 position;
    vec3 velocity;
    vec3 lightMask;
    vec3 lightSample;
};

struct block{
    uint parent;
    uint referenceCount;
    uint type;
    uint root;
	mat4 transformation;
};

uint heapIdxs_loc[2];
uint heapCounts_loc[2];
uint heapHeads_loc[2];

uint taskQIdxs_loc[2];
uint taskQCounts_loc[2];
uint taskQHeads_loc[2];

uint id;
uint swapBit = 1;



/// Yggdrasil Buffer Definitions

layout(std430, binding = 0) buffer DataBuffer { uint data[]; };

layout(std430, binding = 1) buffer BlockBuffer { block data[]; };

layout(std430, binding = 2) buffer HeapBuffer { uint data[]; };

layout(std430, binding = 3) buffer TaskBuffer { uint data[]; };

layout(std430, binding = 4) buffer ExchangeBuffer { uint data[]; };




/// Direct Node Member Access Macros

#define rawNode(node,idx)			DataBuffer.data[ node * NODE_SIZE + idx ]

#define voxelMeta(node)				DataBuffer.data[ node * NODE_SIZE]
#define voxelSurface(node)			DataBuffer.data[ node * NODE_SIZE + 1 ]
#define voxelLight(node)			DataBuffer.data[ node * NODE_SIZE + 2 ]
#define voxelOverlap(node)			DataBuffer.data[ node * NODE_SIZE + 3 ]
#define voxelAttribute(node,idx)	DataBuffer.data[ node * NODE_SIZE + 4 + idx ]
#define voxelChild(node,idx)		DataBuffer.data[ node * NODE_SIZE + 8 + idx ]

#define traceLast(node)					DataBuffer.data[ node * NODE_SIZE ]
#define traceNext(node)					DataBuffer.data[ node * NODE_SIZE + 1 ]
#define traceHostNode(node)				DataBuffer.data[ node * NODE_SIZE + 2 ]
#define traceStackHead(node)			DataBuffer.data[ node * NODE_SIZE + 3 ]
#define traceStackCount(node)			DataBuffer.data[ node * NODE_SIZE + 4 ]
#define traceOverlapHead(node)			DataBuffer.data[ node * NODE_SIZE + 5 ]
#define traceDistanceLeft(node)			DataBuffer.data[ node * NODE_SIZE + 6 ]
#define traceIntegerPosition(node,idx)	DataBuffer.data[ node * NODE_SIZE + 7  + idx ]
#define tracePosition(node,idx)			DataBuffer.data[ node * NODE_SIZE + 10 + idx ]
#define traceVelocity(node,idx)			DataBuffer.data[ node * NODE_SIZE + 13 + idx ]

#define taskLast(node)					DataBuffer.data[ node * NODE_SIZE ]
#define taskNext(node)					DataBuffer.data[ node * NODE_SIZE + 1 ]
#define taskParent(node)				DataBuffer.data[ node * NODE_SIZE + 2 ]
#define taskChildCount(node)			DataBuffer.data[ node * NODE_SIZE + 3 ]

#define traceTaskPosition(node,idx)		DataBuffer.data[ node * NODE_SIZE + 4 + idx ]
#define traceTaskVelocity(node,idx)		DataBuffer.data[ node * NODE_SIZE + 7 + idx ]
#define traceTaskLightMask(node,idx)	DataBuffer.data[ node * NODE_SIZE + 10 + idx ]
#define traceTaskLightSample(node,idx)	DataBuffer.data[ node * NODE_SIZE + 13 + idx ]


/// Node Loading/Storing

traceNode traceLoad(in uint node){
	traceNode result;
    result.last =			traceLast(node);
	result.next =			traceLast(node);
    result.host =			traceHostNode(node);
    result.stackHead =		traceStackHead(node);
    result.stackCount =		traceStackCount(node);
    result.overlapHead = 	traceOverlapHead(node);
    result.distanceLeft =	uintBitsToFloat(traceDistanceLeft(node));
    result.intPosition = 	uvec3(	traceIntegerPosition(node,0),
									traceIntegerPosition(node,1),
									traceIntegerPosition(node,2) );
    result.position = 	vec3(	uintBitsToFloat(tracePosition(node,0)),
								uintBitsToFloat(tracePosition(node,1)),
								uintBitsToFloat(tracePosition(node,2)) );
    result.velocity = 	vec3(	uintBitsToFloat(traceVelocity(node,0)),
								uintBitsToFloat(traceVelocity(node,1)),
								uintBitsToFloat(traceVelocity(node,2)) );
    return result;
}


void traceStore(in uint node, in traceNode trace){
    traceLast(node) =				trace.last;
	traceNext(node) =				trace.next;
    traceHostNode(node) =			trace.host;
    traceStackHead(node) =			trace.stackHead;
    traceStackCount(node) =			trace.stackCount;
    traceOverlapHead(node) =		trace.overlapHead;
    traceDistanceLeft(node) =		floatBitsToUint(trace.distanceLeft);
    traceIntegerPosition(node,0) =	trace.intPosition.x;
    traceIntegerPosition(node,1) =	trace.intPosition.y;
    traceIntegerPosition(node,2) =	trace.intPosition.z;
    tracePosition(node,0) =			floatBitsToUint(trace.position.x);
    tracePosition(node,1) =			floatBitsToUint(trace.position.y);
    tracePosition(node,2) =			floatBitsToUint(trace.position.z);
    traceVelocity(node,0) =			floatBitsToUint(trace.velocity.x);
    traceVelocity(node,1) =			floatBitsToUint(trace.velocity.y);
    traceVelocity(node,2) =			floatBitsToUint(trace.velocity.z);
}




/// Resource Value Indexing Functions

uint heapHeadIdx(in uint idx){
	return heapIdxs_loc[idx]*RSRC_SIZE;
}

uint heapCountIdx(in uint idx){
	return heapIdxs_loc[idx]*RSRC_SIZE + 1;
}

uint heapIdxIdx(int uint idx){
	return RSRC_IDX_OFFSET + idx;
}

uint taskQHeadIdx(in uint idx){
	return taskQIdxs_loc[idx]*RSRC_SIZE;
}

uint taskQCountIdx(in uint idx){
	return taskQIdxs_loc[idx]*RSRC_SIZE + 1;
}

uint taskQIdxIdx(int uint idx){
	return RSRC_IDX_OFFSET + idx;
}




/// Memory Management Functions

uint allocNode(){
	uint bigger = uint(lessThan(heapCounts_loc[0],heapCounts_loc[1]);
	uint result = heapHeads_loc[bigger];
	heapHeads_loc[bigger] = voxelChild(result,0);
	heapCounts_loc[bigger]--;
}

void freeNode( in uint node ){
	uint smaller = uint(greaterThan(heapCounts_loc[0],heapCounts_loc[1]);
	voxelChild(node,0) = heapHeads_loc[smaller];
	heapHeads_loc[smaller] = node;
	heapCounts_loc[smaller]++;
}

void levelHeaps( in uint len ){
	uint bigger = uint(lessThan(heapCounts_loc[0],heapCounts_loc[1]);
	uint smaller = 1-bigger;
	uint diff = abs(heapCounts_loc[0]-heapCounts_loc[1]);
	uint iter = heapHeads_loc[bigger];
	uint holder;
	for(uint i = 0; i < len; i++){
		if(i < diff - 1){
			iter = voxelChild(iter,0);
		}
	}
	if(diff > 0){
		holder = heapHeads_loc[bigger];
		heapHeads_loc[bigger] = voxelChild(iter,0);
		voxelChild(iter,0) = heapHeads_loc[smaller];
        heapHeads_loc[smaller] = holder;
		heapCounts_loc[smaller] += diff;
		heapCounts_loc[bigger] += diff;
	}
}

void pushHeap(in uint idx){
	HeapBuffer.data[heapHeadIdx(idx)] = heapHeads_loc[idx];
	HeapBuffer.data[heapCountIdx(idx)] = heapCounts_loc[idx];
}

void pullHeap(in uint idx){
	heapHeads_loc[idx] = HeapBuffer.data[heapHeadIdx(idx)];
	heapCounts_loc[idx] = HeapBuffer.data[heapCountIdx(idx)];
}

void rotateHeaps(){
	pushHeap(0);
	uint swpIdx = id ^ swapBit;
    heapHeads_loc[0] = atomicExchange(
						HeapBuffer.data[heapIdxIdx(swpIdx)],
						heapIdxs_loc[0]
					);
	heapHeads_loc[0] = atomicExchange(
						HeapBuffer.data[heapIdxIdx[id]],
						heapIdxs_loc[0]
					);
	uint temp = heapIdxs_loc[0];
	heapIdxs_loc[0] = heapIdxs_loc[1];
	heapIdxs_loc[1] = temp;
	id = (id<<1);
	id = (id >= THREAD_COUNT) ? 1 : id;
    pullHeap(0);
}




/// Task Management Functions

uint grabTask(){
	if(taskQCounts_loc[0] | taskQCounts_loc[1] == 0){
		return NOT_THERE;
	}
	uint bigger = uint(lessThan(taskQCounts_loc[0],taskQCounts_loc[1]);
	uint result = taskQHeads_loc[bigger];
	taskQHeads_loc[bigger] = voxelChild(result,0);
	taskQCounts_loc[bigger]--;
	return result;
}

void postTask( in uint node ){
	uint smaller = uint(greaterThan(taskQCounts_loc[0],taskQCounts_loc[1]);
	voxelChild(node,0) = taskQHeads_loc[smaller];
	taskQHeads_loc[smaller] = node;
	taskQCounts_loc[smaller]++;
}

void levelTasks( in uint len ){
	uint bigger = uint(lessThan(taskQCounts_loc[0],taskQCounts_loc[1]);
	uint smaller = 1-bigger;
	uint diff = abs(taskQCounts_loc[0]-taskQCounts_loc[1]);
	uint iter = taskQHeads_loc[bigger];
	uint holder;
	for(uint i = 0; i < len; i++){
		if(i < diff - 1){
			iter = voxelChild(iter,0);
		}
	}
	if(diff > 0){
		holder = taskQHeads_loc[bigger];
		taskQHeads_loc[bigger] = voxelChild(iter,0);
		voxelChild(iter,0) = taskQHeads_loc[smaller];
        taskQHeads_loc[smaller] = holder;
		taskQCounts_loc[smaller] += diff;
		taskQCounts_loc[bigger] += diff;
	}
}


void pushTaskQ(in uint idx){
	TaskBuffer.data[taskQHeadIdx(idx)] = taskQHeads_loc[idx];
	TaskBuffer.data[taskQCountIdx(idx)] = taskQCounts_loc[idx];
}

void pullTaskQ(in uint idx){
	taskQHeads_loc[idx] = TaskBuffer.data[taskQHeadIdx(idx)];
	taskQCounts_loc[idx] = TaskBuffer.data[taskQCountIdx(idx)];
}

void rotateTaskQs(){
	pushTaskQ(0);
	uint swpIdx = id ^ swapBit;
    taskQHeads_loc[0] = atomicExchange(
						TaskBuffer.data[taskQIdxIdx(swpIdx)],
						taskQIdxs_loc[0]
					);
	taskQHeads_loc[0] = atomicExchange(
						TaskQBuffer.data[taskQIdxIdx[id]],
						taskQIdxs_loc[0]
					);
	uint temp = taskQIdxs_loc[0];
	taskQIdxs_loc[0] = taskQIdxs_loc[1];
	taskQIdxs_loc[1] = temp;
	id = (id<<1);
	id = (id >= THREAD_COUNT) ? 1 : id;
    pullTaskQ(0);
}




/// Unsigned Int Stack

void pushStackUint(inout uint top, inout uint count, in uint val){
	uint modPt = count % (NODE_SIZE - 1);
	uint result = top;
    if( modPt == 0 ){
		result = allocNode();
		DataBuffer.data[NODE_SIZE*result] = top;
		top = result;
    }
    DataBuffer[NODE_SIZE*top + 1 + modPt] = val;
    count++;
}

void popStackUint(inout uint top, inout uint count){
	uint modPt = count % (NODE_SIZE - 1);
	uint result = top;
    if( modPt == 1 ){
		result = DataBuffer.data[NODE_SIZE*top];
		freeNode(top);
		top = result;
    }
    count--;
}

// So we can read and write to the stack top cleanly
#define stackTopUint(top,count) DataBuffer[ NODE_SIZE * top + 1 + ( count % ( NODE_SIZE - 1 ) ) ]

void destroyStackUint(inout uint top, inout uint count){
	uint iter = top;
	uint next;
	while(iter != NOT_THERE){
		next = DataBuffer.data[NODE_SIZE*iter];
		freeNode(iter);
		iter = next;
	}
	top = NOT_THERE;
	count = 0;
}


/// Voxel State Traversal Functions




uint childSeek(	in uint voxel, in uint posMask,
				in uvec3 intPosition, in uvec3 targetPosition ){
	uint idx = 0;
    if( ( targetPosition.x & posMask ) > ( intPosition.x & posMask ) ){
		idx |= 1;
    }
    if( ( targetPosition.y & posMask ) > ( intPosition.y & posMask ) ){
		idx |= 2;
    }
    if( ( targetPosition.z & posMask ) > ( intPosition.z & posMask ) ){
		idx |= 4;
    }
    return voxelChild(voxel,idx);
}

vec4 getLocalCoordinates(in vec4 currentCoords, in mat4 childTransform){
	return childTransform * currentCoords;
}

/// Other Stuff

void initYggCompute(){
	id = gl_GlobalInvocationID();
	pullHeap(0);
	pullHeap(1);
	pullTaskQ(0);
	pullTaskQ(1);
	swapMask = 1;
}



